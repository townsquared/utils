{"version":3,"sources":["utils.min.js","utils.js","uiEvent.js","truncate.js","tooltip.js","scrollOn.js","focusOn.js","tsTooltip.js","dropDown.js","autoGrow.js","tsDropDown.js"],"names":["angular","module","directive","$parse","priority","link","$scope","$elm","$attrs","events","$eval","uiEvent","forEach","eventName","fn","bind","evt","params","Array","prototype","slice","call","arguments","splice","$event","$params","$$phase","$apply","filter","value","wordLimit","ellipses","length","undefined","isNumber","words","split","join","$templateCache","$timeout","$compile","$window","restrict","scope","tsTooltip","tsTooltipDirection","tsTooltipEvent","tsTooltipShow","tsTooltipId","tsTooltipClass","tsTooltipContentHover","tsTooltipShowClose","tsTooltipCloseCallback","tsTooltipTrack","tsTooltipMargin","controller","this","setTranscluded","transclude","transcludedContentFn","$element","$attr","addTranscludedContent","clone","tooltipMain","empty","append","tooltipScope","offset","elem","docElem","win","rect","doc","getBoundingClientRect","width","height","getClientRects","ownerDocument","documentElement","top","pageYOffset","clientTop","left","pageXOffset","clientLeft","right","clientWidth","positionTooltip","origOffset","arrowBoxContainer","element","children","elementOffset","leftCommon","topCommon","direction","style","offsetHeight","outerHeight","offsetWidth","ARROW_SIZE","parseInt","makeVisible","isVisible","document","body","insertBefore","tooltipContainer","childNodes","on","isHoveringContent","removeTooltip","find","id","makeInvisible","remove","toggleVisibility","template","get","eventType","$watch","clientHeight","addClass","$","newValue","oldValue","newVal","oldVal","$on","$destroy","off","require","iElem","iAttr","tooltipController","pre","scrollOn","event","location","scrollTop","scrollHeight","focusOnConfig","listener","noop","$observe","speed","parents","targetWindow","animate","complete","focus","extraOffset","focusOnOffset","autoCenter","autoCenterInputs","tagName","toUpperCase","focusOnAutoCenter","window","innerHeight","provider","focusConfig","$get","e","run","put","tsDropDownTemplate","tsDropDown","tsDropDownShow","tsDropDownWidth","tsItemClick","setPlaceholder","placeholderTransclude","setListItem","listItemTransclude","ngModelCtrl","moveHighlightDown","selectedIndex","hasOwnProperty","interactive","highlightedItem","moveHighlightUp","toggleDropDown","forceState","middleOfWindow","middleOfElement","dropDownListContainer","bottom","dropDownOpen","setHeight","dropdownHeight","listHeight","dropDownUnorderedList","updateSelected","selectedValue","placeholderScope","selectedItem","$evalAsync","read","$setViewValue","ae","placeholderElement","attr","container","textDisplayElement","dropDownArrow","querySelector","keyCode","preventDefault","isArray","dropDownItem","$new","item","listItem","createElement","compiledListItem","indexOf","i","child","$render","$viewValue","dropDownController","grow"],"mappings":"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","file":"utils.min.js","sourcesContent":["'use strict';\n\nangular.module('ts.utils', []);\n/**\n * @TODO remove in liue of ui-utils\n * General-purpose Event binding. Bind any event not natively supported by Angular\n * Pass an object with keynames for events to ui-event\n * Allows $event object and $params object to be passed\n *\n * @example <input ui-event=\"{ focus : 'counter++', blur : 'someCallback()' }\">\n * @example <input ui-event=\"{ myCustomEvent : 'myEventHandler($event, $params)'}\">\n *\n * @param ui-event {string|object literal} The event to bind to as a string or a hash of events with their callbacks\n */\n'use strict';\n\nangular.module('ts.utils').directive('uiEvent', function ($parse) {\n    return {\n        priority: 100,\n        link: function link($scope, $elm, $attrs) {\n            var events = $scope.$eval($attrs.uiEvent);\n            angular.forEach(events, function (uiEvent, eventName) {\n                var fn = $parse(uiEvent);\n                $elm.bind(eventName, function (evt) {\n                    var params = Array.prototype.slice.call(arguments);\n                    //Take out first paramater (event object);\n                    params = params.splice(1);\n                    fn($scope, { $event: evt, $params: params });\n                    if (!$scope.$$phase) {\n                        $scope.$apply();\n                    }\n                });\n            });\n        }\n    };\n});\n/**\n * truncate - Truncates a string by a specified number of words\n *\n * @example\n * \t<p>\n * \t\t{{::post.body | truncate : 35}}\n * \t\t<a ng-if=\"::post.body.split(' ').length>35\">Read More</a>\n * \t</p>\n *\n * @param {string} value  The string to be truncated\n * @param {int} [wordLimit] The number of words to truncate at. If falsey, doesn't truncate.\n * @param {string} [ellipses] The string to use as an ellipses. Default: '…' (&hellip;)\n */\n'use strict';\n\nangular.module('ts.utils').filter('tsTruncate', function () {\n  return function (value, wordLimit) {\n    var ellipses = arguments.length <= 2 || arguments[2] === undefined ? '…' : arguments[2];\n\n    if (!value || !angular.isNumber(wordLimit)) return value;\n\n    var words = value.split(' ');\n\n    if (words.length > wordLimit) {\n      value = words.slice(0, wordLimit).join(' ');\n\n      if (ellipses) value += ellipses;\n    }\n\n    return value;\n  };\n});\n/**\n * ts-tooltip - Shows a tooltip with an arrow pointing to the element the directive is applied to.\n *\n * @note depends on jQuery\n *\n * @example\n *\n *<button\n *        ts-tooltip=\"Something that shows up in there\"         // The text to show in the tooltip\n *        ts-tooltip-direction=\"bottom\"                         // The direction the tooltip pops up\n *        ts-tooltip-event=\"click\"                              // Options are click or mouseover\n *        ts-tooltip-show=\"someModel.someBoolean\"               // A boolean if set will use this instead of events\n *        ts-tooltip-id=\"String\"                                // A string used to identify the tooltip\n *        ts-tooltip-class=\"someClass\"                          // Adds class to tooltip container\n *        ts-tooltip-content-hover=\"someModel.someBoolean\"      // A boolean if set will allow users to\n *        ts-tooltip-show-close=\"someModel.someBoolean\"         // A boolean to show close button\n *        ts-tooltip-close-callback=\"someFunction\"              // Event Handler when closed is clicked\n *        ts-tooltip-track=\"someClass\"                          // Tracks height and update if changed\n *        ts-tooltip-margin=\"Integer\"                           // Integer value to provide margin between tooltip and element\n *        >\n *   Bottom Click Me\n * </button>\n *\n */\n\n'use strict';\n\nangular.module('ts.utils').directive('tsTooltip', function ($templateCache, $timeout, $compile, $window) {\n\n  return {\n    restrict: 'A',\n    scope: {\n      tsTooltip: '@',\n      tsTooltipDirection: '@',\n      tsTooltipEvent: '@',\n      tsTooltipShow: '=',\n      tsTooltipId: '@',\n      tsTooltipClass: '@',\n      tsTooltipContentHover: '@',\n      tsTooltipShowClose: '@',\n      tsTooltipCloseCallback: '&',\n      tsTooltipTrack: '@',\n      tsTooltipMargin: '@'\n    },\n    controller: function controller($scope) {\n      $scope.tsTooltipMargin = $scope.tsTooltipMargin ? $scope.tsTooltipMargin : 0;\n      this.setTranscluded = function (transclude) {\n        $scope.transcludedContentFn = transclude;\n      };\n    },\n    link: function link($scope, $element, $attr) {\n      var origOffset;\n      var ARROW_SIZE = 10;\n      var template = $templateCache.get('templates/tsTooltip.html');\n      var direction = $scope.tsTooltipDirection || 'right';\n      var eventType = $scope.tsTooltipEvent || 'mouseenter';\n      var isVisible = false;\n\n      //Compile the container for the bindings on the CSS and text tooltip contents\n      var tooltipContainer = $compile(template)($scope);\n\n      //First DOM element child of the container, this is used for the position computations\n      var arrowBoxContainer = tooltipContainer.children()[0];\n\n      // Fix the position of the tooltip if the height of the tooltip itself changes.  This is necessary for dynamic\n      // content when absolutely positioning the tooltips.  Tooltips must be absolutely positioned in order to be\n      // separated from having their width restricted by their parent element or having a static width and since the\n      // total size of the tooltip is needed to compute the offset for it's top left corner we must watch the height.\n      $scope.$watch(function () {\n        return arrowBoxContainer.clientHeight;\n      }, positionTooltip);\n\n      //We need a good workaround for if the contents width changes to adjust to fix the position, less $watchers is ideal\n      // $scope.$watch(function(){return arrowBoxContainer.clientWidth}, positionTooltip);\n\n      // This is where we add the transcluded content will get placed it is one of the children of the container\n      $scope.tooltipMain = tooltipContainer.find('#tooltipMain');\n      $scope.tooltipMain.addClass(direction);\n\n      function addTranscludedContent() {\n        if ($scope.transcludedContentFn) {\n          $scope.transcludedContentFn(function (clone, scope) {\n            $scope.tooltipMain.empty();\n            $scope.tooltipMain.append(clone);\n            $scope.tooltipScope = scope;\n          });\n        }\n      }\n\n      // Taken from jQuery so we don't have to directly depend on it for this\n      // calculates the top left offsets for a given element.\n      function offset(elem) {\n        var docElem, win, rect, doc;\n\n        if (!elem) {\n          return;\n        }\n\n        rect = elem.getBoundingClientRect();\n\n        // Make sure element is not hidden (display: none) or disconnected\n        if (rect.width || rect.height || elem.getClientRects().length) {\n          doc = elem.ownerDocument;\n          win = $window;\n          docElem = doc.documentElement;\n\n          return {\n            top: rect.top + win.pageYOffset - docElem.clientTop,\n            left: rect.left + win.pageXOffset - docElem.clientLeft,\n            right: docElem.clientWidth - rect.left\n          };\n        }\n      }\n\n      function positionTooltip() {\n        if (!origOffset) origOffset = offset(arrowBoxContainer);\n        var element = $element.children().length == 1 ? $element.children() : $element;\n        var elementOffset = offset(element[0]);\n\n        if (elementOffset === undefined || origOffset == undefined) {\n          return;\n        }\n        var leftCommon = elementOffset.left - origOffset.left,\n            topCommon = elementOffset.top - origOffset.top;\n\n        //Sets the common top for left and right, or common left for top and bottom\n        switch (direction) {\n          case 'right':\n          case 'left':\n            arrowBoxContainer.style.top = topCommon + element[0].offsetHeight - $scope.tooltipMain[0].offsetHeight / 2 - element.outerHeight() / 2 + 'px';\n            break;\n          case 'top':\n          case 'bottom':\n            arrowBoxContainer.style.left = leftCommon + element[0].offsetWidth / 2 - $scope.tooltipMain[0].offsetWidth / 2 + 'px';\n            break;\n        }\n\n        //Sets the specific left or top values for each direction\n        switch (direction) {\n          case 'right':\n            arrowBoxContainer.style.left = leftCommon + element[0].offsetWidth + ARROW_SIZE + parseInt($scope.tsTooltipMargin) + 'px';\n            break;\n          case 'left':\n            arrowBoxContainer.style.right = elementOffset.right + ARROW_SIZE + parseInt($scope.tsTooltipMargin) + 'px';\n            break;\n          case 'top':\n            arrowBoxContainer.style.top = topCommon - $scope.tooltipMain[0].offsetHeight - ARROW_SIZE - parseInt($scope.tsTooltipMargin) + 'px';\n            break;\n          case 'bottom':\n            arrowBoxContainer.style.top = topCommon + element[0].offsetHeight + ARROW_SIZE + parseInt($scope.tsTooltipMargin) + 'px';\n            break;\n        }\n      }\n\n      function makeVisible() {\n        if (!isVisible) {\n          document.body.insertBefore(tooltipContainer[0], document.body.childNodes[0]);\n          addTranscludedContent();\n          positionTooltip();\n          isVisible = true;\n          if ($scope.tsTooltipContentHover) {\n            angular.element(tooltipContainer).on('mouseleave', function () {\n              $scope.isHoveringContent = false;\n              removeTooltip();\n            });\n            angular.element(tooltipContainer).on('mouseenter', function () {\n              $scope.isHoveringContent = true;\n            });\n          } else {\n            angular.element(tooltipContainer.find('.close')).on('click', function () {\n              removeTooltip();\n              if ($scope.tsTooltipCloseCallback) $scope.tsTooltipCloseCallback({ id: $scope.tsTooltipId });\n            });\n          }\n        }\n      }\n\n      function makeInvisible() {\n        if (isVisible) {\n          if ($scope.tsTooltipContentHover) {\n            $timeout(function () {\n              if ($scope.isHoveringContent) return;else {\n                removeTooltip();\n              }\n            }, 250);\n          } else {\n            removeTooltip();\n          }\n        }\n      }\n\n      function removeTooltip() {\n        isVisible = false;\n        tooltipContainer.remove();\n      }\n\n      function toggleVisibility() {\n        isVisible ? makeInvisible() : makeVisible();\n      }\n\n      if ($attr.tsTooltipShow === undefined) {\n        switch (eventType) {\n          case 'mouseenter':\n            $element.on('mouseenter', makeVisible);\n            $element.on('mouseleave', makeInvisible);\n            break;\n          case 'click':\n            $element.on('click', toggleVisibility);\n            break;\n          case 'hybrid':\n            $element.on('mouseenter', makeVisible);\n            $element.on('mouseleave', makeInvisible);\n            $element.on('click', toggleVisibility);\n            break;\n        }\n      } else {\n        angular.element($window).on('resize', positionTooltip);\n\n        if ($scope.tsTooltipTrack) {\n          $scope.$watch(function () {\n            return $($scope.tsTooltipTrack).height();\n          }, function (newValue, oldValue) {\n            if (newValue != oldValue) positionTooltip();\n          });\n        }\n\n        $scope.$watch('tsTooltipShow', function (newVal, oldVal) {\n          if (newVal) {\n            // 250ms is an estimate to wait for the render of elements using ng-ifs\n            $timeout(function () {\n              return makeVisible();\n            }, 250);\n          } else {\n            makeInvisible();\n          }\n        });\n      }\n\n      //Clean up the tooltip and destroy the scope for the transcluded element\n      $scope.$on('$destroy', function () {\n        if ($scope.tooltipScope) $scope.tooltipScope.$destroy();\n        angular.element(arrowBoxContainer).remove();\n        angular.element($window).off('resize', positionTooltip);\n      });\n    }\n  };\n}).directive('tsTooltipContent', function () {\n  return {\n    restrict: 'E',\n    require: '^tsTooltip',\n    transclude: 'element',\n    link: function link(scope, iElem, iAttr, tooltipController, transclude) {\n      tooltipController.setTranscluded(transclude);\n    }\n  };\n});\n\n/**\n * scrollOn - $broadcast()/$emit() a $scope event with the location to trigger scrolling\n *\n * @example\n *   <ul scroll-on=\"someEventName\" style=\"overflow: auto\">...</ul>\n *   ...\n *   var location = 'bottom';\n *   $scope.$broadcast('someEventName', location)\n *\n * @param location {'top'|'bottom'|offset} must be passed as event data\n */\n'use strict';\n\nangular.module('ts.utils').directive('scrollOn', function ($timeout) {\n  return {\n    link: {\n      pre: function pre($scope, $element, $attrs) {\n        $scope.$on($attrs.scrollOn, function (event, location) {\n          // let updates render\n          $timeout(function () {\n            if (location === 'bottom') {\n              $element[0].scrollTop = $element[0].scrollHeight;\n            } else if (location === 'top') {\n              $element[0].scrollTop = 0;\n            } else {\n              $element[0].scrollTop = location;\n            }\n          }, true);\n        });\n      }\n    }\n  };\n});\n/**\n * focusOn - Focuses an input on scope event\n *\n * @note depends on jQuery\n *\n * @example\n *   <input focus-on=\"someEventName\">\n *   or\n *   <input focus-on=\"focus-row-{{$index}}\">\n *   or\n *   <p focus-on=\"anotherEvent\"></p>\n *   ...\n *   $scope.$broadcast('someEventName');\n *   $scope.$broadcast('focus-row-2');\n *   $scope.$broadcast('anotherEvent');\n *\n *   focusOnConfigProvider - can be injected into a .config(function(focusOnConfigProvider){}) block to configure the\n *   app wide settings for the focusOn directive\n *\n *   Settings include:\n *      offset - number of pixels to offset the scroll to for a header or other info that appears above the element you\n *      want to scroll to the top of the screen.  The offset is subtracted from the computed scroll position\n *\n *      autoCenter - boolean if true will use the element height and document body height to scroll the element to the\n *      center of the screen instead of the top\n *\n *   App wide settings can be overridden using attributes along with the focus-on directive.  The attributes for the\n *   offset and autoCenter are focus-on-offset and focus-on-auto-center respectively.\n *\n */\n'use strict';\n\nangular.module('ts.utils').directive('focusOn', function ($window, focusOnConfig) {\n  return {\n    link: function link($scope, $element, $attrs) {\n      var listener = angular.noop;\n      $attrs.$observe('focusOn', function (newVal) {\n        // Stop listening to old event name\n        listener();\n        // Listen to new event name\n        listener = $scope.$on(newVal, function (speed) {\n          speed = speed || 1000;\n          // Center element on screen\n          if ($element.parents('.reveal-modal').length) {\n            var targetWindow = $element.parents('.reveal-modal .content');\n            targetWindow.animate({\n              scrollTop: $element.offset().top - targetWindow.offset().top + targetWindow.scrollTop()\n            }, {\n              speed: speed,\n              complete: function complete() {\n                // Focus element (if input)\n                $element[0].focus();\n              }\n            });\n          } else {\n            var offset = $element.offset().top;\n\n            // Use provider configured offset\n            var extraOffset = focusOnConfig.offset;\n\n            // If attribute is set override provider configured offset\n            if ($attrs.focusOnOffset !== undefined) {\n              extraOffset = parseInt($attrs.focusOnOffset);\n            }\n\n            // Check if provider or attribute set autoCenter/auto-center to true if so use offset/2 ignores the extra\n            // offset in this case\n            if ((focusOnConfig.autoCenter || focusOnConfig.autoCenterInputs && $element[0].tagName.toUpperCase() == 'INPUT' || focusOnConfig.autoCenterInputs && $element[0].tagName.toUpperCase() == 'TEXTAREA') && $attrs.focusOnAutoCenter === undefined || $attrs.focusOnAutoCenter && $attrs.focusOnAutoCenter == 'true') {\n              offset = offset - window.innerHeight / 2 - $element[0].clientHeight / 2;\n            } else {\n              offset = offset - extraOffset;\n            }\n\n            $('body').animate({ scrollTop: offset }, {\n              speed: speed,\n              complete: function complete() {\n                // Focus element (if input)\n                $element[0].focus();\n              }\n            });\n          }\n        });\n      });\n    }\n  };\n}).provider('focusOnConfig', function () {\n  var focusConfig = {\n    offset: 0,\n    autoCenter: false,\n    autoCenterInputs: false\n  };\n\n  this.autoCenter = function (value) {\n    focusConfig.autoCenter = value;\n  };\n\n  this.autoCenterInputs = function (value) {\n    focusConfig.autoCenterInputs = value;\n  };\n\n  this.offset = function (value) {\n    focusConfig.offset = value;\n  };\n\n  this.$get = function () {\n    return focusConfig;\n  };\n});\n'use strict';\n\n(function (module) {\n  try {\n    module = angular.module('ts.utils');\n  } catch (e) {\n    module = angular.module('ts.utils', []);\n  }\n  module.run(['$templateCache', function ($templateCache) {\n    $templateCache.put('templates/tsTooltip.html', '<div class=\"ts-tooltip-container {{::tsTooltipClass}}\">\\n' + '  <div class=\"arrow-box-container\">\\n' + '    <div id=\"tooltipMain\" class=\"ts-tooltip-main\" ng-class=\"{\\'ts-tooltip-close\\': tsTooltipShowClose}\">\\n' + '      <div class=\"close\" ng-show=\"tsTooltipShowClose\">\\n' + '  \t    <a href=\"#\" ng-click=\"close()\"><small><i class=\"icon-close icon\" aria-hidden=\"true\"></i></small></a>\\n' + '  \t  </div>\\n' + '      {{tsTooltip}}\\n' + '    </div>\\n' + '  </div>\\n' + '</div>\\n' + '');\n  }]);\n})();\n/**\n * ts-dropwdown - Shows a drop down list of items that can be selected from.\n *\n * @note depends on jQuery\n *\n * @example\n *\n *\n */\n\n'use strict';\nangular.module('ts.utils').directive('tsDropDown', function ($templateCache, $compile, $timeout) {\n\n  return {\n    restrict: 'A',\n    require: 'ngModel',\n    //transclude: {\n    //  'listItem':'tsListItem',\n    //  'placeholder':'tsPlaceholder'\n    //},\n    scope: {\n      tsDropDownTemplate: '@',\n      tsDropDown: '=',\n      tsDropDownShow: '=?',\n      tsDropDownWidth: '=',\n      tsItemClick: '&'\n    },\n    controller: function controller($scope) {\n      this.setPlaceholder = function (transclude) {\n        $scope.placeholderTransclude = transclude;\n      };\n      this.setListItem = function (transclude) {\n        $scope.listItemTransclude = transclude;\n      };\n    },\n\n    link: function link($scope, $element, $attr, ngModelCtrl) {\n      var selectedIndex = 0,\n          ae = angular.element,\n          //shorthand\n      placeholderElement = undefined,\n          placeholderScope = undefined,\n          selectedItem = undefined,\n          setHeight = false;\n\n      //Makes the element focusable with the keyboard\n      $element.attr('tabindex', '0');\n\n      $scope.direction = 'down';\n      $scope.dropDownOpen = false;\n\n      var template = $templateCache.get('templates/tsDropDown.html');\n      var container = $compile(template)($scope); //Container for all the drop down related parts\n      $element.append(container);\n\n      var textDisplayElement = ae(container.children()[0]),\n          //First child of the container is the place to put the placeholder or selected item\n      dropDownArrow = ae(container.children()[1]),\n          //Second child is the drop down arrow/button\n      dropDownListContainer = ae(container.children()[2]),\n          //Third child is the list container\n      dropDownUnorderedList = ae($element[0].querySelector('ul'));\n\n      $element.on('keydown', function (event) {\n        switch (event.keyCode) {\n          case 13:\n            //enter\n            updateSelected($scope.highlightedItem);\n            toggleDropDown();\n            event.preventDefault();\n            break;\n\n          case 38:\n            //up\n\n            // If list isn't open, open it\n            if (!$scope.dropDownOpen) {\n              toggleDropDown();\n            } else {\n              // otherwise if the list is open move up in the highlights.\n              $scope.$apply(moveHighlightUp);\n            }\n            event.preventDefault();\n            break;\n\n          case 40:\n            //down\n\n            //If list isn't open, open it\n            if (!$scope.dropDownOpen) {\n              toggleDropDown();\n            } else {\n              $scope.$apply(moveHighlightDown);\n            }\n            event.preventDefault();\n            break;\n        }\n      });\n\n      function moveHighlightDown() {\n        while ($scope.tsDropDown.length - 1 > selectedIndex) {\n          selectedIndex++;\n          if (!$scope.tsDropDown[selectedIndex].hasOwnProperty('interactive') || $scope.tsDropDown[selectedIndex].interactive === true) break;\n        }\n        $scope.highlightedItem = $scope.tsDropDown[selectedIndex];\n      }\n\n      function moveHighlightUp() {\n        while (0 < selectedIndex) {\n          selectedIndex--;\n          if (!$scope.tsDropDown[selectedIndex].hasOwnProperty('interactive') || $scope.tsDropDown[selectedIndex].interactive === true) break;\n        }\n        $scope.highlightedItem = $scope.tsDropDown[selectedIndex];\n      }\n\n      $scope.$watch('tsDropDown', function () {\n        if (angular.isArray($scope.tsDropDown)) {\n          $scope.tsDropDown.forEach(function (dropDownItem) {\n\n            if ($scope.listItemTransclude) {\n              $scope.listItemTransclude($scope.$new(), function (clone, scope) {\n                scope.item = dropDownItem;\n\n                var listItem = ae(document.createElement('li'));\n                listItem.attr('ng-class', '{\"highlighted\":highlightedItem==item}');\n                var compiledListItem = $compile(listItem)(scope);\n                compiledListItem.append(clone[0]);\n\n                //Adds event handlers if the item isn't explicitly marked non interactive\n                if (!dropDownItem.hasOwnProperty('interactive') || dropDownItem.interactive === true) {\n                  compiledListItem.on('click', function () {\n                    updateSelected(dropDownItem);\n                    if ($scope.tsItemClick) $scope.tsItemClick({ item: dropDownItem });\n                    $scope.$apply(toggleDropDown);\n                  });\n                  compiledListItem.on('mouseenter', function () {\n                    $scope.highlightedItem = scope.item;\n                    selectedIndex = $scope.tsDropDown.indexOf(scope.item);\n                    $scope.$apply();\n                  });\n                }\n\n                compiledListItem[0].style.width = (scope.tsDropDownWidth || textDisplayElement[0].offsetWidth + dropDownArrow[0].offsetWidth) + 'px';\n\n                dropDownUnorderedList.append(compiledListItem);\n              });\n            }\n          });\n        }\n      });\n\n      $scope.$watch('tsDropDownWidth', function (newVal) {\n        if (newVal) {\n          for (var i = 0; i < dropDownUnorderedList.children().length; i++) {\n            var child = dropDownUnorderedList.children()[i];\n            child.style.width = newVal + 'px';\n          }\n        }\n      });\n\n      //Initialize to first item is highlighted\n      $scope.highlightedItem = $scope.tsDropDown[selectedIndex];\n\n      if ($scope.placeholderTransclude) {\n        $scope.placeholderTransclude($scope.$new(), function (clone, scope) {\n          placeholderScope = scope;\n          placeholderElement = clone[0];\n\n          textDisplayElement.append(clone[0]);\n        });\n      }\n\n      // Take the height of the window divided by 2 to get the middle of the window\n      // if the element's middle is lower than the middle of the window then open upward\n      // otherwise open downward\n      function toggleDropDown(forceState) {\n        var rect = $element[0].getBoundingClientRect();\n        var middleOfWindow = window.innerHeight / 2;\n        var middleOfElement = rect.top + rect.height / 2;\n\n        if (middleOfElement > middleOfWindow) {\n          $scope.direction = 'up';\n\n          dropDownListContainer[0].style.bottom = rect.height + 'px';\n          dropDownListContainer[0].style.top = 'auto';\n        } else {\n          dropDownListContainer[0].style.top = rect.height + 'px';\n          dropDownListContainer[0].style.bottom = 'auto';\n          $scope.direction = 'down';\n        }\n\n        if (forceState === true || forceState === false) {\n          $scope.dropDownOpen = forceState;\n        } else {\n          $scope.dropDownOpen = !$scope.dropDownOpen;\n          $scope.tsDropDownShow = $scope.dropDownOpen;\n        }\n        if (setHeight) return;\n\n        $timeout(function () {\n          setHeight = true;\n          var dropdownHeight;\n          var listHeight = dropDownUnorderedList.outerHeight() + 2;\n          if (listHeight > window.innerHeight * .33) dropdownHeight = window.innerHeight * .33;else dropdownHeight = listHeight;\n          dropDownListContainer[0].style.height = dropdownHeight + 'px';\n        }, 0);\n      }\n\n      textDisplayElement.on('click', function () {\n        $scope.$apply(toggleDropDown);\n      });\n      dropDownArrow.on('click', function () {\n        $scope.$apply(toggleDropDown);\n      });\n\n      $scope.$watch('tsDropDownShow', function (newVal, oldVal) {\n        if (newVal !== undefined) toggleDropDown(newVal);\n      });\n\n      if (!ngModelCtrl) return; // do nothing if no ng-model\n\n      function updateSelected(selectedValue) {\n        placeholderScope.selectedItem = selectedItem = selectedValue;\n        $scope.$evalAsync(read);\n      }\n\n      $element.on('blur', function () {\n        $scope.$apply(function () {\n          $scope.dropDownOpen = false;\n        });\n      });\n\n      // Specify how UI should be updated when the model changes from outside\n      ngModelCtrl.$render = function () {\n        //update selected element text\n        updateSelected(ngModelCtrl.$viewValue || '');\n      };\n\n      // Write data to the model\n      function read() {\n        ngModelCtrl.$setViewValue(selectedItem);\n      }\n    }\n\n  };\n}).directive('tsPlaceholder', function () {\n  return {\n    restrict: 'E',\n    require: '^tsDropDown',\n    transclude: 'element',\n    link: function link(scope, iElem, iAttr, dropDownController, transclude) {\n      dropDownController.setPlaceholder(transclude);\n    }\n  };\n}).directive('tsListItem', function () {\n  return {\n    restrict: 'E',\n    require: '^tsDropDown',\n    transclude: 'element',\n    link: function link(scope, iElem, iAttr, dropDownController, transclude) {\n      dropDownController.setListItem(transclude);\n    }\n  };\n});\n/**\n * autoGrow - Increases height of textarea while typing\n *\n * @note use with min-height, max-height and box-sizing:border-box\n *\n * @example\n * \t<textarea auto-grow></textarea>\n */\n'use strict';\n\nangular.module('ts.utils').directive('autoGrow', function ($timeout) {\n  return {\n    restrict: 'A',\n    link: function link($scope, $element, $attrs) {\n      function grow() {\n        $element[0].style.height = 0; // autoshrink - need accurate scrollHeight\n        $element[0].style.height = $element[0].scrollHeight + 'px';\n      }\n      $element.on('input', grow);\n      $timeout(grow, true);\n    }\n  };\n});\n'use strict';\n\n(function (module) {\n  try {\n    module = angular.module('ts.utils');\n  } catch (e) {\n    module = angular.module('ts.utils', []);\n  }\n  module.run(['$templateCache', function ($templateCache) {\n    $templateCache.put('templates/tsDropDown.html', '<div class=\"drop-down-container\">\\n' + '  <div class=\"selected-item-container\"></div>\\n' + '  <div class=\"arrow-container\" ng-class=\"{\\'arrow-default\\':!dropDownOpen, \\'arrow-open\\':dropDownOpen}\"></div>\\n' + '  <div ng-show=\"dropDownOpen\" class=\"drop-down-list-container\">\\n' + '    <ul></ul>\\n' + '  </div>\\n' + '</div>');\n  }]);\n})();","angular.module('ts.utils', []);\n","/**\n * @TODO remove in liue of ui-utils\n * General-purpose Event binding. Bind any event not natively supported by Angular\n * Pass an object with keynames for events to ui-event\n * Allows $event object and $params object to be passed\n *\n * @example <input ui-event=\"{ focus : 'counter++', blur : 'someCallback()' }\">\n * @example <input ui-event=\"{ myCustomEvent : 'myEventHandler($event, $params)'}\">\n *\n * @param ui-event {string|object literal} The event to bind to as a string or a hash of events with their callbacks\n */\nangular.module('ts.utils').directive('uiEvent', function ($parse) {\n    return {\n        priority: 100,\n        link: function ($scope, $elm, $attrs) {\n            var events = $scope.$eval($attrs.uiEvent);\n            angular.forEach(events, function (uiEvent, eventName) {\n                var fn = $parse(uiEvent);\n                $elm.bind(eventName, function (evt) {\n                    var params = Array.prototype.slice.call(arguments);\n                    //Take out first paramater (event object);\n                    params = params.splice(1);\n                    fn($scope, {$event: evt, $params: params});\n                    if (!$scope.$$phase) {\n                        $scope.$apply();\n                    }\n                });\n            });\n        }\n    };\n});\n","/**\n * truncate - Truncates a string by a specified number of words\n *\n * @example\n * \t<p>\n * \t\t{{::post.body | truncate : 35}}\n * \t\t<a ng-if=\"::post.body.split(' ').length>35\">Read More</a>\n * \t</p>\n *\n * @param {string} value  The string to be truncated\n * @param {int} [wordLimit] The number of words to truncate at. If falsey, doesn't truncate.\n * @param {string} [ellipses] The string to use as an ellipses. Default: '…' (&hellip;)\n */\n angular.module('ts.utils').filter('tsTruncate', function() {\n  return function(value, wordLimit, ellipses = '…'){\n    if (!value || !angular.isNumber(wordLimit))\n      return value;\n\n    var words = value.split(' ');\n\n    if (words.length > wordLimit) {\n      value = words.slice(0, wordLimit).join(' ');\n\n      if (ellipses)\n        value += ellipses;\n    }\n\n    return value;\n  }\n});\n","/**\n * ts-tooltip - Shows a tooltip with an arrow pointing to the element the directive is applied to.\n *\n * @note depends on jQuery\n *\n * @example\n *\n *<button\n *        ts-tooltip=\"Something that shows up in there\"         // The text to show in the tooltip\n *        ts-tooltip-direction=\"bottom\"                         // The direction the tooltip pops up\n *        ts-tooltip-event=\"click\"                              // Options are click or mouseover\n *        ts-tooltip-show=\"someModel.someBoolean\"               // A boolean if set will use this instead of events\n *        ts-tooltip-id=\"String\"                                // A string used to identify the tooltip\n *        ts-tooltip-class=\"someClass\"                          // Adds class to tooltip container\n *        ts-tooltip-content-hover=\"someModel.someBoolean\"      // A boolean if set will allow users to\n *        ts-tooltip-show-close=\"someModel.someBoolean\"         // A boolean to show close button\n *        ts-tooltip-close-callback=\"someFunction\"              // Event Handler when closed is clicked\n *        ts-tooltip-track=\"someClass\"                          // Tracks height and update if changed\n *        ts-tooltip-margin=\"Integer\"                           // Integer value to provide margin between tooltip and element\n *        >\n *   Bottom Click Me\n * </button>\n *\n */\n\n'use strict';\n\nangular.module('ts.utils')\n\n  .directive('tsTooltip', function($templateCache, $timeout, $compile, $window){\n\n    return {\n      restrict:'A',\n      scope:{\n        tsTooltip:'@',\n        tsTooltipDirection:'@',\n        tsTooltipEvent:'@',\n        tsTooltipShow:'=',\n        tsTooltipId: '@',\n        tsTooltipClass: '@',\n        tsTooltipContentHover: '@',\n        tsTooltipShowClose: '@',\n        tsTooltipCloseCallback: '&',\n        tsTooltipTrack: '@',\n        tsTooltipMargin: '@'\n      },\n      controller: function($scope){\n        $scope.tsTooltipMargin = $scope.tsTooltipMargin ? $scope.tsTooltipMargin : 0;\n        this.setTranscluded = function(transclude){\n          $scope.transcludedContentFn = transclude;\n        }\n      },\n      link: function($scope, $element, $attr) {\n        var origOffset;\n        var ARROW_SIZE = 10;\n        var template = $templateCache.get('templates/tsTooltip.html');\n        var direction = $scope.tsTooltipDirection || 'right';\n        var eventType = $scope.tsTooltipEvent || 'mouseenter';\n        var isVisible = false;\n\n        //Compile the container for the bindings on the CSS and text tooltip contents\n        var tooltipContainer = $compile(template)($scope);\n\n        //First DOM element child of the container, this is used for the position computations\n        var arrowBoxContainer = tooltipContainer.children()[0];\n\n        // Fix the position of the tooltip if the height of the tooltip itself changes.  This is necessary for dynamic\n        // content when absolutely positioning the tooltips.  Tooltips must be absolutely positioned in order to be\n        // separated from having their width restricted by their parent element or having a static width and since the\n        // total size of the tooltip is needed to compute the offset for it's top left corner we must watch the height.\n        $scope.$watch(function(){return arrowBoxContainer.clientHeight}, positionTooltip);\n\n        //We need a good workaround for if the contents width changes to adjust to fix the position, less $watchers is ideal\n        // $scope.$watch(function(){return arrowBoxContainer.clientWidth}, positionTooltip);\n\n        // This is where we add the transcluded content will get placed it is one of the children of the container\n        $scope.tooltipMain = tooltipContainer.find('#tooltipMain');\n        $scope.tooltipMain.addClass(direction);\n\n        function addTranscludedContent(){\n          if($scope.transcludedContentFn){\n            $scope.transcludedContentFn(function(clone, scope) {\n              $scope.tooltipMain.empty();\n              $scope.tooltipMain.append(clone);\n              $scope.tooltipScope = scope;\n            });\n          }\n        }\n\n        // Taken from jQuery so we don't have to directly depend on it for this\n        // calculates the top left offsets for a given element.\n        function offset( elem ) {\n          var docElem, win, rect, doc;\n\n          if ( !elem ) {\n            return;\n          }\n\n          rect = elem.getBoundingClientRect();\n\n          // Make sure element is not hidden (display: none) or disconnected\n          if ( rect.width || rect.height || elem.getClientRects().length ) {\n            doc = elem.ownerDocument;\n            win = $window;\n            docElem = doc.documentElement;\n\n            return {\n              top: rect.top + win.pageYOffset - docElem.clientTop,\n              left: rect.left + win.pageXOffset - docElem.clientLeft,\n              right: docElem.clientWidth - rect.left\n            };\n          }\n        }\n\n        function positionTooltip(){\n          if(!origOffset)\n            origOffset = offset(arrowBoxContainer);\n          var element = $element.children().length == 1 ? $element.children() : $element;\n          let elementOffset = offset(element[0]);\n\n          if(elementOffset === undefined || origOffset == undefined) {\n            return;\n          }\n          let leftCommon = elementOffset.left-origOffset.left,\n            topCommon = elementOffset.top-origOffset.top;\n\n          //Sets the common top for left and right, or common left for top and bottom\n          switch(direction){\n            case 'right':\n            case 'left':\n              arrowBoxContainer.style.top = topCommon + element[0].offsetHeight - $scope.tooltipMain[0].offsetHeight / 2 - element.outerHeight() / 2 + 'px';\n              break;\n            case 'top':\n            case 'bottom':\n              arrowBoxContainer.style.left = leftCommon + element[0].offsetWidth / 2 - $scope.tooltipMain[0].offsetWidth / 2 + 'px';\n              break;\n          }\n\n          //Sets the specific left or top values for each direction\n          switch(direction) {\n            case 'right':\n              arrowBoxContainer.style.left = (leftCommon + element[0].offsetWidth + ARROW_SIZE + parseInt($scope.tsTooltipMargin)) + 'px';\n              break;\n            case 'left':\n              arrowBoxContainer.style.right = (elementOffset.right + ARROW_SIZE + parseInt($scope.tsTooltipMargin)) + 'px';\n              break;\n            case 'top':\n              arrowBoxContainer.style.top = (topCommon - $scope.tooltipMain[0].offsetHeight - ARROW_SIZE - parseInt($scope.tsTooltipMargin)) + 'px';\n              break;\n            case 'bottom':\n              arrowBoxContainer.style.top = (topCommon + element[0].offsetHeight + ARROW_SIZE + parseInt($scope.tsTooltipMargin)) + 'px';\n              break;\n          }\n        }\n\n        function makeVisible() {\n          if (!isVisible) {\n            document.body.insertBefore(tooltipContainer[0], document.body.childNodes[0]);\n            addTranscludedContent();\n            positionTooltip();\n            isVisible = true;\n            if($scope.tsTooltipContentHover) {\n              angular.element(tooltipContainer).on('mouseleave', function(){\n                $scope.isHoveringContent = false;\n                removeTooltip();\n              });\n              angular.element(tooltipContainer).on('mouseenter', function(){\n                $scope.isHoveringContent = true;\n              });\n            } else {\n              angular.element(tooltipContainer.find('.close')).on('click', function(){\n                removeTooltip();\n                if ($scope.tsTooltipCloseCallback) $scope.tsTooltipCloseCallback({id: $scope.tsTooltipId});\n              });\n            }\n          }\n        }\n\n        function makeInvisible() {\n          if (isVisible) {\n            if($scope.tsTooltipContentHover) {\n              $timeout( () => {\n                if($scope.isHoveringContent)\n                  return;\n                else {\n                  removeTooltip();\n                }\n              }, 250)\n            } else {\n              removeTooltip();\n            }\n          }\n        }\n\n        function removeTooltip() {\n          isVisible = false;\n          tooltipContainer.remove();\n        }\n\n        function toggleVisibility() {\n          isVisible ? makeInvisible() : makeVisible();\n        }\n\n        if($attr.tsTooltipShow === undefined) {\n          switch(eventType) {\n            case 'mouseenter':\n              $element.on('mouseenter', makeVisible);\n              $element.on('mouseleave', makeInvisible);\n              break;\n            case 'click':\n              $element.on('click', toggleVisibility);\n              break;\n            case 'hybrid':\n              $element.on('mouseenter', makeVisible);\n              $element.on('mouseleave', makeInvisible);\n              $element.on('click', toggleVisibility);\n              break;\n          }\n        }\n        else{\n          angular.element($window).on('resize', positionTooltip);\n\n          if ($scope.tsTooltipTrack) {\n            $scope.$watch(() => $($scope.tsTooltipTrack).height(),\n              function (newValue, oldValue) {\n                if (newValue != oldValue) positionTooltip();\n              }\n            );\n          }\n\n          $scope.$watch('tsTooltipShow',function(newVal, oldVal) {\n            if(newVal) {\n              // 250ms is an estimate to wait for the render of elements using ng-ifs \n              $timeout(() => makeVisible(), 250);\n            }\n            else {\n              makeInvisible();\n            }\n          })\n        }\n\n        //Clean up the tooltip and destroy the scope for the transcluded element\n        $scope.$on('$destroy',function() {\n          if($scope.tooltipScope)\n            $scope.tooltipScope.$destroy();\n          angular.element(arrowBoxContainer).remove();\n          angular.element($window).off('resize', positionTooltip);\n        });\n      }\n    };\n  })\n  .directive('tsTooltipContent', function(){\n    return {\n      restrict:'E',\n      require: '^tsTooltip',\n      transclude: 'element',\n      link: function(scope, iElem, iAttr, tooltipController, transclude){\n        tooltipController.setTranscluded(transclude);\n      }\n    }\n  })\n;\n","\n/**\n * scrollOn - $broadcast()/$emit() a $scope event with the location to trigger scrolling\n *\n * @example\n *   <ul scroll-on=\"someEventName\" style=\"overflow: auto\">...</ul>\n *   ...\n *   var location = 'bottom';\n *   $scope.$broadcast('someEventName', location)\n *\n * @param location {'top'|'bottom'|offset} must be passed as event data\n */\nangular.module('ts.utils').directive('scrollOn', function($timeout) {\n  return {\n    link: {\n      pre: function($scope, $element, $attrs) {\n        $scope.$on($attrs.scrollOn, function(event, location){\n          // let updates render\n          $timeout(function(){\n            if (location === 'bottom') {\n              $element[0].scrollTop = $element[0].scrollHeight;\n            }\n            else if (location === 'top') {\n              $element[0].scrollTop = 0;\n            }\n            else {\n              $element[0].scrollTop = location;\n            }\n          }, true);\n        });\n      }\n    }\n  };\n});\n","/**\n * focusOn - Focuses an input on scope event\n *\n * @note depends on jQuery\n *\n * @example\n *   <input focus-on=\"someEventName\">\n *   or\n *   <input focus-on=\"focus-row-{{$index}}\">\n *   or\n *   <p focus-on=\"anotherEvent\"></p>\n *   ...\n *   $scope.$broadcast('someEventName');\n *   $scope.$broadcast('focus-row-2');\n *   $scope.$broadcast('anotherEvent');\n *\n *   focusOnConfigProvider - can be injected into a .config(function(focusOnConfigProvider){}) block to configure the\n *   app wide settings for the focusOn directive\n *\n *   Settings include:\n *      offset - number of pixels to offset the scroll to for a header or other info that appears above the element you\n *      want to scroll to the top of the screen.  The offset is subtracted from the computed scroll position\n *\n *      autoCenter - boolean if true will use the element height and document body height to scroll the element to the\n *      center of the screen instead of the top\n *\n *   App wide settings can be overridden using attributes along with the focus-on directive.  The attributes for the\n *   offset and autoCenter are focus-on-offset and focus-on-auto-center respectively.\n *\n */\nangular.module('ts.utils')\n  .directive('focusOn', function($window, focusOnConfig){\n    return {\n      link: function($scope, $element, $attrs) {\n        var listener = angular.noop;\n        $attrs.$observe('focusOn', function(newVal){\n          // Stop listening to old event name\n          listener();\n          // Listen to new event name\n          listener = $scope.$on(newVal, function(speed){\n            speed = speed || 1000;\n            // Center element on screen\n            if($element.parents('.reveal-modal').length) {\n              var targetWindow = $element.parents('.reveal-modal .content');\n              targetWindow.animate({\n                scrollTop: $element.offset().top - targetWindow.offset().top + targetWindow.scrollTop()\n              }, {\n                speed: speed,\n                complete: function complete() {\n                  // Focus element (if input)\n                  $element[0].focus();\n                }\n              });\n            }\n            else {\n              var offset = $element.offset().top;\n\n              // Use provider configured offset\n              var extraOffset = focusOnConfig.offset;\n\n              // If attribute is set override provider configured offset\n              if($attrs.focusOnOffset !== undefined){\n                extraOffset = parseInt($attrs.focusOnOffset);\n              }\n\n              // Check if provider or attribute set autoCenter/auto-center to true if so use offset/2 ignores the extra\n              // offset in this case\n              if(\n                (\n                (\n                  focusOnConfig.autoCenter ||\n                  focusOnConfig.autoCenterInputs && $element[0].tagName.toUpperCase()=='INPUT' ||\n                  focusOnConfig.autoCenterInputs && $element[0].tagName.toUpperCase()=='TEXTAREA'\n                )\n                && $attrs.focusOnAutoCenter===undefined ) ||\n                ($attrs.focusOnAutoCenter && $attrs.focusOnAutoCenter=='true') ) {\n                offset = offset - window.innerHeight/2 - $element[0].clientHeight/2;\n              }\n              else{\n                offset = offset - extraOffset;\n              }\n\n              $('body').animate({ scrollTop: offset }, {\n                speed: speed,\n                complete: function complete() {\n                  // Focus element (if input)\n                  $element[0].focus();\n                }\n              });\n            }\n          });\n        });\n      }\n    };\n  })\n\n  .provider('focusOnConfig', function(){\n    var focusConfig = {\n      offset: 0,\n      autoCenter:false,\n      autoCenterInputs:false\n    };\n\n    this.autoCenter = function(value){\n      focusConfig.autoCenter = value;\n    };\n\n    this.autoCenterInputs = function(value){\n      focusConfig.autoCenterInputs = value;\n    };\n\n    this.offset = function(value){\n      focusConfig.offset = value;\n    };\n\n    this.$get = function(){\n      return focusConfig;\n    };\n\n  });","(function(module) {\ntry {\n  module = angular.module('ts.utils');\n} catch (e) {\n  module = angular.module('ts.utils', []);\n}\nmodule.run(['$templateCache', function($templateCache) {\n  $templateCache.put('templates/tsTooltip.html',\n    '<div class=\"ts-tooltip-container {{::tsTooltipClass}}\">\\n' +\n    '  <div class=\"arrow-box-container\">\\n' +\n    '    <div id=\"tooltipMain\" class=\"ts-tooltip-main\" ng-class=\"{\\'ts-tooltip-close\\': tsTooltipShowClose}\">\\n' +\n    '      <div class=\"close\" ng-show=\"tsTooltipShowClose\">\\n' +\n    '  \t    <a href=\"#\" ng-click=\"close()\"><small><i class=\"icon-close icon\" aria-hidden=\"true\"></i></small></a>\\n' +\n    '  \t  </div>\\n' +\n    '      {{tsTooltip}}\\n' +\n    '    </div>\\n' +\n    '  </div>\\n' +\n    '</div>\\n' +\n    '');\n}]);\n})();\n","/**\n * ts-dropwdown - Shows a drop down list of items that can be selected from.\n *\n * @note depends on jQuery\n *\n * @example\n *\n *\n */\n\n'use strict';\nangular.module('ts.utils')\n\n  .directive('tsDropDown', function($templateCache, $compile, $timeout) {\n\n    return {\n      restrict:'A',\n      require: 'ngModel',\n      //transclude: {\n      //  'listItem':'tsListItem',\n      //  'placeholder':'tsPlaceholder'\n      //},\n      scope:{\n        tsDropDownTemplate:'@',\n        tsDropDown: '=',\n        tsDropDownShow:'=?',\n        tsDropDownWidth: '=',\n        tsItemClick: '&'\n      },\n      controller: function($scope){\n        this.setPlaceholder = function(transclude){\n          $scope.placeholderTransclude = transclude;\n        }\n        this.setListItem = function(transclude){\n          $scope.listItemTransclude = transclude;\n        }\n      },\n\n      link: function($scope, $element, $attr, ngModelCtrl) {\n        let selectedIndex = 0,\n            ae = angular.element, //shorthand\n            placeholderElement,\n            placeholderScope,\n            selectedItem,\n            setHeight = false;\n\n        //Makes the element focusable with the keyboard\n        $element.attr('tabindex','0');\n\n        $scope.direction = 'down';\n        $scope.dropDownOpen = false;\n\n        var template = $templateCache.get('templates/tsDropDown.html');\n        var container = $compile(template)($scope); //Container for all the drop down related parts\n        $element.append(container);\n\n        let textDisplayElement = ae(container.children()[0]), //First child of the container is the place to put the placeholder or selected item\n          dropDownArrow = ae(container.children()[1]), //Second child is the drop down arrow/button\n          dropDownListContainer = ae(container.children()[2]), //Third child is the list container\n          dropDownUnorderedList = ae($element[0].querySelector('ul'))\n\n        $element.on('keydown', function(event) {\n          switch(event.keyCode){\n            case 13: //enter\n              updateSelected($scope.highlightedItem);\n              toggleDropDown();\n              event.preventDefault();\n              break;\n\n            case 38: //up\n\n              // If list isn't open, open it\n              if(!$scope.dropDownOpen) {\n                toggleDropDown();\n              }\n              else { // otherwise if the list is open move up in the highlights.\n                $scope.$apply(moveHighlightUp);\n              }\n              event.preventDefault();\n              break;\n\n            case 40: //down\n\n              //If list isn't open, open it\n              if(!$scope.dropDownOpen) {\n                toggleDropDown();\n              } else {\n                $scope.$apply(moveHighlightDown);\n              }\n              event.preventDefault();\n              break;\n          }\n        });\n\n        function moveHighlightDown() {\n          while($scope.tsDropDown.length-1>selectedIndex) {\n            selectedIndex++;\n            if( !$scope.tsDropDown[selectedIndex].hasOwnProperty('interactive') ||\n                $scope.tsDropDown[selectedIndex].interactive === true)\n              break;\n          }\n          $scope.highlightedItem = $scope.tsDropDown[selectedIndex];\n        }\n\n        function moveHighlightUp() {\n          while(0<selectedIndex) {\n            selectedIndex--;\n            if( !$scope.tsDropDown[selectedIndex].hasOwnProperty('interactive') ||\n                $scope.tsDropDown[selectedIndex].interactive === true)\n              break;\n          }\n          $scope.highlightedItem = $scope.tsDropDown[selectedIndex];\n        }\n\n\n        $scope.$watch('tsDropDown', function(){\n          if(angular.isArray($scope.tsDropDown)){\n            $scope.tsDropDown.forEach(function(dropDownItem) {\n\n              if($scope.listItemTransclude){\n                $scope.listItemTransclude($scope.$new(), function(clone, scope) {\n                  scope.item = dropDownItem;\n\n                  var listItem = ae(document.createElement('li'));\n                  listItem.attr('ng-class', '{\"highlighted\":highlightedItem==item}');\n                  var compiledListItem = $compile(listItem)(scope);\n                  compiledListItem.append(clone[0]);\n\n                  //Adds event handlers if the item isn't explicitly marked non interactive\n                  if( !dropDownItem.hasOwnProperty('interactive') ||\n                    dropDownItem.interactive === true) {\n                    compiledListItem.on('click', function() {\n                      updateSelected(dropDownItem);\n                      if($scope.tsItemClick)\n                        $scope.tsItemClick({item:dropDownItem});\n                      $scope.$apply(toggleDropDown);\n                    });\n                    compiledListItem.on('mouseenter', function(){\n                      $scope.highlightedItem = scope.item;\n                      selectedIndex = $scope.tsDropDown.indexOf(scope.item);\n                      $scope.$apply();\n                    });\n\n                  }\n\n                  compiledListItem[0].style.width = (scope.tsDropDownWidth || textDisplayElement[0].offsetWidth + dropDownArrow[0].offsetWidth) + 'px';\n\n                  dropDownUnorderedList.append(compiledListItem);\n                });\n              }\n            });\n          }\n\n\n        });\n\n\n        $scope.$watch('tsDropDownWidth', function(newVal){\n          if(newVal){\n            for (var i = 0; i < dropDownUnorderedList.children().length; i++) {\n              var child = dropDownUnorderedList.children()[i];\n              child.style.width = newVal + 'px';\n            }\n          }\n        });\n\n        //Initialize to first item is highlighted\n        $scope.highlightedItem = $scope.tsDropDown[selectedIndex];\n\n        if($scope.placeholderTransclude){\n          $scope.placeholderTransclude($scope.$new(), function(clone, scope){\n            placeholderScope = scope;\n            placeholderElement = clone[0];\n\n            textDisplayElement.append(clone[0]);\n          });\n        }\n\n        // Take the height of the window divided by 2 to get the middle of the window\n        // if the element's middle is lower than the middle of the window then open upward\n        // otherwise open downward\n        function toggleDropDown(forceState){\n          var rect = $element[0].getBoundingClientRect();\n          var middleOfWindow = window.innerHeight/2;\n          var middleOfElement = rect.top+rect.height/2;\n\n          if(middleOfElement>middleOfWindow){\n            $scope.direction = 'up';\n\n            dropDownListContainer[0].style.bottom = rect.height+'px';\n            dropDownListContainer[0].style.top = 'auto';\n          }\n          else{\n            dropDownListContainer[0].style.top = rect.height+'px';\n            dropDownListContainer[0].style.bottom = 'auto';\n            $scope.direction = 'down';\n          }\n\n\n          if(forceState === true || forceState === false) {\n            $scope.dropDownOpen = forceState;\n          }\n          else{\n            $scope.dropDownOpen = !$scope.dropDownOpen;\n            $scope.tsDropDownShow = $scope.dropDownOpen;\n          }\n          if(setHeight)\n            return;\n\n          $timeout( () => {\n            setHeight = true;\n            var dropdownHeight;\n            var listHeight = dropDownUnorderedList.outerHeight() + 2;\n            if(listHeight > (window.innerHeight * .33) )\n              dropdownHeight = window.innerHeight*.33;\n            else\n              dropdownHeight = listHeight\n            dropDownListContainer[0].style.height = dropdownHeight + 'px';\n          }, 0);\n        }\n\n        textDisplayElement.on('click', function(){\n          $scope.$apply(toggleDropDown)\n        });\n        dropDownArrow.on('click', function(){\n          $scope.$apply(toggleDropDown)\n        });\n\n\n        $scope.$watch('tsDropDownShow',function(newVal, oldVal) {\n          if(newVal !== undefined)\n            toggleDropDown(newVal);\n        })\n\n        if (!ngModelCtrl) return; // do nothing if no ng-model\n\n        function updateSelected(selectedValue){\n          placeholderScope.selectedItem = selectedItem = selectedValue;\n          $scope.$evalAsync(read);\n        }\n\n\n        $element.on('blur', function(){\n          $scope.$apply(function(){\n            $scope.dropDownOpen = false;\n          });\n        });\n\n        // Specify how UI should be updated when the model changes from outside\n        ngModelCtrl.$render = function() {\n          //update selected element text\n          updateSelected(ngModelCtrl.$viewValue || '');\n        };\n\n        // Write data to the model\n        function read() {\n          ngModelCtrl.$setViewValue(selectedItem);\n        }\n      }\n\n    };\n  })\n\n  .directive('tsPlaceholder', function(){\n    return {\n      restrict:'E',\n      require: '^tsDropDown',\n      transclude: 'element',\n      link: function(scope, iElem, iAttr, dropDownController, transclude){\n        dropDownController.setPlaceholder(transclude);\n      }\n    }\n  })\n\n  .directive('tsListItem', function(){\n    return {\n      restrict:'E',\n      require: '^tsDropDown',\n      transclude: 'element',\n      link: function(scope, iElem, iAttr, dropDownController, transclude){\n        dropDownController.setListItem(transclude);\n      }\n    }\n  });\n","/**\n * autoGrow - Increases height of textarea while typing\n *\n * @note use with min-height, max-height and box-sizing:border-box\n *\n * @example\n * \t<textarea auto-grow></textarea>\n */\n angular.module('ts.utils').directive('autoGrow', function($timeout) {\n  return {\n    restrict: 'A',\n    link: function($scope, $element, $attrs) {\n      function grow() {\n        $element[0].style.height = 0; // autoshrink - need accurate scrollHeight\n        $element[0].style.height = $element[0].scrollHeight + 'px';\n      }\n      $element.on('input', grow);\n      $timeout(grow, true);\n    }\n  }\n});\n","(function(module) {\ntry {\n  module = angular.module('ts.utils');\n} catch (e) {\n  module = angular.module('ts.utils', []);\n}\nmodule.run(['$templateCache', function($templateCache) {\n  $templateCache.put('templates/tsDropDown.html',\n    '<div class=\"drop-down-container\">\\n' +\n    '  <div class=\"selected-item-container\"></div>\\n' +\n    '  <div class=\"arrow-container\" ng-class=\"{\\'arrow-default\\':!dropDownOpen, \\'arrow-open\\':dropDownOpen}\"></div>\\n' +\n    '  <div ng-show=\"dropDownOpen\" class=\"drop-down-list-container\">\\n' +\n    '    <ul></ul>\\n' +\n    '  </div>\\n' +\n    '</div>');\n}]);\n})();\n"]}