{"version":3,"sources":["utils.min.js","utils.js","uiEvent.js","truncate.js","scrollOn.js","focusOn.js","dropDown.js","autoGrow.js","tsDropDown.js"],"names":["angular","module","directive","$parse","priority","link","$scope","$elm","$attrs","events","$eval","uiEvent","forEach","eventName","fn","bind","evt","params","Array","prototype","slice","call","arguments","splice","$event","$params","$$phase","$apply","filter","value","wordLimit","ellipses","length","undefined","isNumber","words","split","join","$timeout","pre","$element","$on","scrollOn","event","location","scrollTop","scrollHeight","$window","focusOnConfig","listener","noop","$observe","newVal","speed","parents","targetWindow","animate","offset","top","complete","focus","extraOffset","focusOnOffset","parseInt","autoCenter","focusOnAutoCenter","window","document","body","clientHeight","$","provider","_offset","_autoCenter","this","$get","$templateCache","$compile","$log","restrict","require","transclude","listItem","placeholder","scope","tsDropDownTemplate","tsDropDown","templateUrl","$attr","ngModelCtrl","$transclude","toggleDropDown","rect","getBoundingClientRect","middleOfWindow","innerHeight","middleOfElement","height","direction","dropDownListContainer","style","bottom","i","dropDownUnorderedList","children","childElement","prepend","dropDownOpen","updateSelected","selectedValue","placeholderScope","selectedItem","$evalAsync","read","$setViewValue","dropDownContainer","element","textDisplayElement","dropDownArrow","querySelector","on","keyCode","preventDefault","console","log","dropDownItem","$new","clone","item","createElement","append","width","offsetWidth","placeholderElement","$render","$viewValue","grow","e","run","put"],"mappings":"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","file":"utils.min.js","sourcesContent":["'use strict';\n\nangular.module('ts.utils', []);\n/**\n * @TODO remove in liue of ui-utils\n * General-purpose Event binding. Bind any event not natively supported by Angular\n * Pass an object with keynames for events to ui-event\n * Allows $event object and $params object to be passed\n *\n * @example <input ui-event=\"{ focus : 'counter++', blur : 'someCallback()' }\">\n * @example <input ui-event=\"{ myCustomEvent : 'myEventHandler($event, $params)'}\">\n *\n * @param ui-event {string|object literal} The event to bind to as a string or a hash of events with their callbacks\n */\n'use strict';\n\nangular.module('ts.utils').directive('uiEvent', function ($parse) {\n    return {\n        priority: 100,\n        link: function link($scope, $elm, $attrs) {\n            var events = $scope.$eval($attrs.uiEvent);\n            angular.forEach(events, function (uiEvent, eventName) {\n                var fn = $parse(uiEvent);\n                $elm.bind(eventName, function (evt) {\n                    var params = Array.prototype.slice.call(arguments);\n                    //Take out first paramater (event object);\n                    params = params.splice(1);\n                    fn($scope, { $event: evt, $params: params });\n                    if (!$scope.$$phase) {\n                        $scope.$apply();\n                    }\n                });\n            });\n        }\n    };\n});\n/**\n * truncate - Truncates a string by a specified number of words\n *\n * @example\n * \t<p>\n * \t\t{{::post.body | truncate : 35}}\n * \t\t<a ng-if=\"::post.body.split(' ').length>35\">Read More</a>\n * \t</p>\n *\n * @param {string} value  The string to be truncated\n * @param {int} [wordLimit] The number of words to truncate at. If falsey, doesn't truncate.\n * @param {string} [ellipses] The string to use as an ellipses. Default: '…' (&hellip;)\n */\n'use strict';\n\nangular.module('ts.utils').filter('tsTruncate', function () {\n  return function (value, wordLimit) {\n    var ellipses = arguments.length <= 2 || arguments[2] === undefined ? '…' : arguments[2];\n\n    if (!value || !angular.isNumber(wordLimit)) return value;\n\n    var words = value.split(' ');\n\n    if (words.length > wordLimit) {\n      value = words.slice(0, wordLimit).join(' ');\n\n      if (ellipses) value += ellipses;\n    }\n\n    return value;\n  };\n});\n\n/**\n * scrollOn - $broadcast()/$emit() a $scope event with the location to trigger scrolling\n *\n * @example\n *   <ul scroll-on=\"someEventName\" style=\"overflow: auto\">...</ul>\n *   ...\n *   var location = 'bottom';\n *   $scope.$broadcast('someEventName', location)\n *\n * @param location {'top'|'bottom'|offset} must be passed as event data\n */\n'use strict';\n\nangular.module('ts.utils').directive('scrollOn', function ($timeout) {\n  return {\n    link: {\n      pre: function pre($scope, $element, $attrs) {\n        $scope.$on($attrs.scrollOn, function (event, location) {\n          // let updates render\n          $timeout(function () {\n            if (location === 'bottom') {\n              $element[0].scrollTop = $element[0].scrollHeight;\n            } else if (location === 'top') {\n              $element[0].scrollTop = 0;\n            } else {\n              $element[0].scrollTop = location;\n            }\n          }, true);\n        });\n      }\n    }\n  };\n});\n/**\n * focusOn - Focuses an input on scope event\n *\n * @note depends on jQuery\n *\n * @example\n *   <input focus-on=\"someEventName\">\n *   or\n *   <input focus-on=\"focus-row-{{$index}}\">\n *   or\n *   <p focus-on=\"anotherEvent\"></p>\n *   ...\n *   $scope.$broadcast('someEventName');\n *   $scope.$broadcast('focus-row-2');\n *   $scope.$broadcast('anotherEvent');\n *\n *   focusOnConfigProvider - can be injected into a .config(function(focusOnConfigProvider){}) block to configure the\n *   app wide settings for the focusOn directive\n *\n *   Settings include:\n *      offset - number of pixels to offset the scroll to for a header or other info that appears above the element you\n *      want to scroll to the top of the screen.  The offset is subtracted from the computed scroll position\n *\n *      autoCenter - boolean if true will use the element height and document body height to scroll the element to the\n *      center of the screen instead of the top\n *\n *   App wide settings can be overridden using attributes along with the focus-on directive.  The attributes for the\n *   offset and autoCenter are focus-on-offset and focus-on-auto-center respectively.\n *\n */\n'use strict';\n\nangular.module('ts.utils').directive('focusOn', function ($window, focusOnConfig) {\n  return {\n    link: function link($scope, $element, $attrs) {\n      var listener = angular.noop;\n      $attrs.$observe('focusOn', function (newVal) {\n        // Stop listening to old event name\n        listener();\n        // Listen to new event name\n        listener = $scope.$on(newVal, function () {\n          var speed = arguments.length <= 0 || arguments[0] === undefined ? 1000 : arguments[0];\n\n          // Center element on screen\n          if ($element.parents('.reveal-modal').length) {\n            var targetWindow = $element.parents('.reveal-modal .content');\n            targetWindow.animate({\n              scrollTop: $element.offset().top - targetWindow.offset().top + targetWindow.scrollTop()\n            }, {\n              speed: speed,\n              complete: function complete() {\n                // Focus element (if input)\n                $element[0].focus();\n              }\n            });\n          } else {\n            var offset = $element.offset().top;\n\n            // Use provider configured offset\n            var extraOffset = focusOnConfig.offset;\n\n            // If attribute is set override provider configured offset\n            if ($attrs.focusOnOffset !== undefined) {\n              extraOffset = parseInt($attrs.focusOnOffset);\n            }\n\n            // Check if provider or attribute set autoCenter/auto-center to true if so use offset/2 ignores the extra\n            // offset in this case\n            if (focusOnConfig.autoCenter && $attrs.focusOnAutoCenter === undefined || $attrs.focusOnAutoCenter && $attrs.focusOnAutoCenter == 'true') {\n              offset = offset - window.document.body.clientHeight / 2 + $element[0].clientHeight / 2;\n            } else {\n              offset = offset - extraOffset;\n            }\n\n            $('body').animate({ scrollTop: offset }, {\n              speed: speed,\n              complete: function complete() {\n                // Focus element (if input)\n                $element[0].focus();\n              }\n            });\n          }\n        });\n      });\n    }\n  };\n}).provider('focusOnConfig', function () {\n  var _offset = 0;\n  var _autoCenter = false;\n\n  this.autoCenter = function (value) {\n    _autoCenter = value;\n  };\n\n  this.offset = function (value) {\n    _offset = value;\n  };\n\n  this.$get = function () {\n    return {\n      offset: _offset,\n      autoCenter: _autoCenter\n    };\n  };\n});\n/**\n * ts-dropwdown - Shows a drop down list of items that can be selected from.\n *\n * @note depends on jQuery\n *\n * @example\n *\n *\n */\n\n'use strict';\n\nangular.module('ts.utils').directive('tsDropDown', function ($templateCache, $compile, $log) {\n\n  return {\n    restrict: 'A',\n    require: 'ngModel',\n    transclude: {\n      'listItem': 'tsListItem',\n      'placeholder': 'tsPlaceholder'\n    },\n    scope: {\n      tsDropDownTemplate: '@',\n      tsDropDown: '='\n    },\n    templateUrl: 'templates/tsDropDown.html',\n    link: function link($scope, $element, $attr, ngModelCtrl, $transclude) {\n      var selectedItem = 'default selected item';\n\n      var dropDownContainer = angular.element($element.children()[0]);\n      var textDisplayElement = angular.element(dropDownContainer.children()[0]);\n      var dropDownArrow = angular.element(dropDownContainer.children()[1]);\n      var dropDownListContainer = angular.element(dropDownContainer.children()[2]);\n      var dropDownUnorderedList = angular.element($element[0].querySelector('ul'));\n\n      $scope.direction = 'down';\n\n      $scope.dropDownOpen = false;\n\n      $element.on('keydown', function (event) {\n        switch (event.keyCode) {\n          case 37:\n            //left\n            break;\n          case 38:\n            //up\n            event.preventDefault();\n            break;\n          case 39:\n            //right\n            break;\n          case 40:\n            //down\n            event.preventDefault();\n            break;\n          case 13:\n            //enter\n            toggleDropDown();\n            break;\n        }\n        console.log(event.keyCode);\n      });\n\n      $scope.tsDropDown.forEach(function (dropDownItem) {\n        $transclude($scope.$new(), function (clone, scope) {\n          scope.item = dropDownItem;\n\n          var listItem = angular.element(document.createElement('li'));\n          listItem.append(clone[0]);\n\n          listItem.on('click', function () {\n            updateSelected(dropDownItem);\n            $scope.$apply(toggleDropDown);\n          });\n          listItem[0].style.width = textDisplayElement[0].offsetWidth - 12 + 'px';\n\n          dropDownUnorderedList.append(listItem);\n        }, null, 'listItem');\n      });\n\n      var placeholderElement, placeholderScope;\n\n      $transclude($scope.$new(), function (clone, scope) {\n        placeholderScope = scope;\n        placeholderElement = clone[0];\n\n        textDisplayElement.append(clone[0]);\n      }, null, 'placeholder');\n\n      // Take the height of the window divided by 2 to get the middle of the window\n      // if the element's middle is lower than the middle of the window then open upward\n      // otherwise open downward\n      function toggleDropDown() {\n        var rect = $element[0].getBoundingClientRect();\n        var middleOfWindow = window.innerHeight / 2;\n        var middleOfElement = rect.top + rect.height / 2;\n\n        if (middleOfElement > middleOfWindow) {\n          $scope.direction = 'up';\n\n          dropDownListContainer[0].style.bottom = rect.height + 'px';\n          dropDownListContainer[0].style.top = 'auto';\n\n          //Flips the items in the list when opening upward\n          for (var i = 0; i < dropDownUnorderedList.children().length; i++) {\n            var childElement = dropDownUnorderedList.children()[i];\n            dropDownUnorderedList.prepend(childElement);\n          }\n        } else {\n          dropDownListContainer[0].style.top = rect.height + 'px';\n          dropDownListContainer[0].style.bottom = 'auto';\n          $scope.direction = 'down';\n        }\n\n        $scope.dropDownOpen = !$scope.dropDownOpen;\n      }\n\n      textDisplayElement.on('click', function () {\n        $scope.$apply(toggleDropDown);\n      });\n      dropDownArrow.on('click', function () {\n        $scope.$apply(toggleDropDown);\n      });\n\n      if (!ngModelCtrl) return; // do nothing if no ng-model\n\n      // Specify how UI should be updated\n      ngModelCtrl.$render = function () {\n        //update selected element text\n        updateSelected(ngModelCtrl.$viewValue || '');\n      };\n\n      function updateSelected(selectedValue) {\n        placeholderScope.selectedItem = selectedItem = selectedValue;\n        $scope.$evalAsync(read);\n      }\n\n      // Listen for change events to enable binding\n      $element.on('blur keyup', function () {\n\n        $scope.$evalAsync(read);\n        ngModelCtrl.$render();\n      });\n      read(); // initialize\n\n      // Write data to the model\n      function read() {\n        ngModelCtrl.$setViewValue(selectedItem);\n      }\n    }\n\n  };\n});\n/**\n * autoGrow - Increases height of textarea while typing\n *\n * @note use with min-height, max-height and box-sizing:border-box\n *\n * @example\n * \t<textarea auto-grow></textarea>\n */\n'use strict';\n\nangular.module('ts.utils').directive('autoGrow', function ($timeout) {\n  return {\n    restrict: 'A',\n    link: function link($scope, $element, $attrs) {\n      function grow() {\n        $element[0].style.height = 0; // autoshrink - need accurate scrollHeight\n        $element[0].style.height = $element[0].scrollHeight + 'px';\n      }\n      $element.on('input', grow);\n      $timeout(grow, true);\n    }\n  };\n});\n'use strict';\n\n(function (module) {\n  try {\n    module = angular.module('ts.utils');\n  } catch (e) {\n    module = angular.module('ts.utils', []);\n  }\n  module.run(['$templateCache', function ($templateCache) {\n    $templateCache.put('templates/tsDropDown.html', '<div class=\"drop-down-container\">\\n' + '  <div class=\"selected-item-container\">\\n' + '  </div><div class=\"arrow-container\">\\n' + '    <div ng-if=\"!dropDownOpen\" class=\"drop-down-arrow\"><i class=\"fa fa-angle-down\"></i></div>\\n' + '    <div ng-if=\"dropDownOpen\" class=\"drop-down-arrow\"><i class=\"fa fa-angle-up\"></i></div>\\n' + '  </div>\\n' + '  <div ng-show=\"dropDownOpen\"\\n' + '       class=\"drop-down-list-container\">\\n' + '    <ul>\\n' + '    </ul>\\n' + '  </div>\\n' + '</div>');\n  }]);\n})();","angular.module('ts.utils', []);\n","/**\n * @TODO remove in liue of ui-utils\n * General-purpose Event binding. Bind any event not natively supported by Angular\n * Pass an object with keynames for events to ui-event\n * Allows $event object and $params object to be passed\n *\n * @example <input ui-event=\"{ focus : 'counter++', blur : 'someCallback()' }\">\n * @example <input ui-event=\"{ myCustomEvent : 'myEventHandler($event, $params)'}\">\n *\n * @param ui-event {string|object literal} The event to bind to as a string or a hash of events with their callbacks\n */\nangular.module('ts.utils').directive('uiEvent', function ($parse) {\n    return {\n        priority: 100,\n        link: function ($scope, $elm, $attrs) {\n            var events = $scope.$eval($attrs.uiEvent);\n            angular.forEach(events, function (uiEvent, eventName) {\n                var fn = $parse(uiEvent);\n                $elm.bind(eventName, function (evt) {\n                    var params = Array.prototype.slice.call(arguments);\n                    //Take out first paramater (event object);\n                    params = params.splice(1);\n                    fn($scope, {$event: evt, $params: params});\n                    if (!$scope.$$phase) {\n                        $scope.$apply();\n                    }\n                });\n            });\n        }\n    };\n});\n","/**\n * truncate - Truncates a string by a specified number of words\n *\n * @example\n * \t<p>\n * \t\t{{::post.body | truncate : 35}}\n * \t\t<a ng-if=\"::post.body.split(' ').length>35\">Read More</a>\n * \t</p>\n *\n * @param {string} value  The string to be truncated\n * @param {int} [wordLimit] The number of words to truncate at. If falsey, doesn't truncate.\n * @param {string} [ellipses] The string to use as an ellipses. Default: '…' (&hellip;)\n */\n angular.module('ts.utils').filter('tsTruncate', function() {\n  return function(value, wordLimit, ellipses = '…'){\n    if (!value || !angular.isNumber(wordLimit))\n      return value;\n\n    var words = value.split(' ');\n\n    if (words.length > wordLimit) {\n      value = words.slice(0, wordLimit).join(' ');\n\n      if (ellipses)\n        value += ellipses;\n    }\n\n    return value;\n  }\n});\n","\n/**\n * scrollOn - $broadcast()/$emit() a $scope event with the location to trigger scrolling\n *\n * @example\n *   <ul scroll-on=\"someEventName\" style=\"overflow: auto\">...</ul>\n *   ...\n *   var location = 'bottom';\n *   $scope.$broadcast('someEventName', location)\n *\n * @param location {'top'|'bottom'|offset} must be passed as event data\n */\nangular.module('ts.utils').directive('scrollOn', function($timeout) {\n  return {\n    link: {\n      pre: function($scope, $element, $attrs) {\n        $scope.$on($attrs.scrollOn, function(event, location){\n          // let updates render\n          $timeout(function(){\n            if (location === 'bottom') {\n              $element[0].scrollTop = $element[0].scrollHeight;\n            }\n            else if (location === 'top') {\n              $element[0].scrollTop = 0;\n            }\n            else {\n              $element[0].scrollTop = location;\n            }\n          }, true);\n        });\n      }\n    }\n  };\n});\n","/**\n * focusOn - Focuses an input on scope event\n *\n * @note depends on jQuery\n *\n * @example\n *   <input focus-on=\"someEventName\">\n *   or\n *   <input focus-on=\"focus-row-{{$index}}\">\n *   or\n *   <p focus-on=\"anotherEvent\"></p>\n *   ...\n *   $scope.$broadcast('someEventName');\n *   $scope.$broadcast('focus-row-2');\n *   $scope.$broadcast('anotherEvent');\n *\n *   focusOnConfigProvider - can be injected into a .config(function(focusOnConfigProvider){}) block to configure the\n *   app wide settings for the focusOn directive\n *\n *   Settings include:\n *      offset - number of pixels to offset the scroll to for a header or other info that appears above the element you\n *      want to scroll to the top of the screen.  The offset is subtracted from the computed scroll position\n *\n *      autoCenter - boolean if true will use the element height and document body height to scroll the element to the\n *      center of the screen instead of the top\n *\n *   App wide settings can be overridden using attributes along with the focus-on directive.  The attributes for the\n *   offset and autoCenter are focus-on-offset and focus-on-auto-center respectively.\n *\n */\n angular.module('ts.utils').directive('focusOn', function($window, focusOnConfig){\n  return {\n    link: function($scope, $element, $attrs) {\n      var listener = angular.noop;\n      $attrs.$observe('focusOn', function(newVal){\n        // Stop listening to old event name\n        listener();\n        // Listen to new event name\n        listener = $scope.$on(newVal, function(speed = 1000){\n          // Center element on screen\n          if($element.parents('.reveal-modal').length) {\n            var targetWindow = $element.parents('.reveal-modal .content');\n            targetWindow.animate({\n              scrollTop: $element.offset().top - targetWindow.offset().top + targetWindow.scrollTop()\n            }, {\n              speed: speed,\n              complete: function complete() {\n                // Focus element (if input)\n                $element[0].focus();\n              }\n            });\n          }\n          else {\n            var offset = $element.offset().top;\n\n            // Use provider configured offset\n            var extraOffset = focusOnConfig.offset;\n\n            // If attribute is set override provider configured offset\n            if($attrs.focusOnOffset !== undefined){\n              extraOffset = parseInt($attrs.focusOnOffset);\n            }\n\n            // Check if provider or attribute set autoCenter/auto-center to true if so use offset/2 ignores the extra\n            // offset in this case\n            if( (focusOnConfig.autoCenter && $attrs.focusOnAutoCenter===undefined ) ||\n                ($attrs.focusOnAutoCenter && $attrs.focusOnAutoCenter=='true') ) {\n              offset = offset - window.document.body.clientHeight/2 + $element[0].clientHeight/2;\n            }\n            else{\n              offset = offset - extraOffset;\n            }\n\n            $('body').animate({ scrollTop: offset }, {\n              speed: speed,\n              complete: function complete() {\n                // Focus element (if input)\n                $element[0].focus();\n              }\n            });\n          }\n        });\n      });\n    }\n  };\n})\n\n.provider('focusOnConfig', function(){\n  var _offset = 0;\n  var _autoCenter = false;\n\n  this.autoCenter = function(value){\n    _autoCenter = value;\n  };\n\n  this.offset = function(value){\n    _offset = value;\n  };\n\n  this.$get = function(){\n    return {\n      offset: _offset,\n      autoCenter:_autoCenter\n    };\n  };\n\n});\n","/**\n * ts-dropwdown - Shows a drop down list of items that can be selected from.\n *\n * @note depends on jQuery\n *\n * @example\n *\n *\n */\n\n\nangular.module('ts.utils')\n\n  .directive('tsDropDown', function($templateCache, $compile, $log){\n\n    return {\n      restrict:'A',\n      require: 'ngModel',\n      transclude: {\n        'listItem':'tsListItem',\n        'placeholder':'tsPlaceholder'\n      },\n      scope:{\n        tsDropDownTemplate:'@',\n        tsDropDown: '='\n      },\n      templateUrl:'templates/tsDropDown.html',\n      link: function($scope, $element, $attr, ngModelCtrl, $transclude) {\n        var selectedItem = 'default selected item';\n\n        var dropDownContainer = angular.element($element.children()[0]);\n        var textDisplayElement = angular.element(dropDownContainer.children()[0]);\n        var dropDownArrow = angular.element(dropDownContainer.children()[1]);\n        var dropDownListContainer = angular.element(dropDownContainer.children()[2]);\n        var dropDownUnorderedList = angular.element($element[0].querySelector('ul'));\n\n        $scope.direction = 'down';\n\n        $scope.dropDownOpen = false;\n\n        $element.on('keydown', function(event){\n          switch(event.keyCode){\n            case 37: //left\n              break;\n            case 38: //up\n              event.preventDefault();\n              break;\n            case 39: //right\n              break;\n            case 40: //down\n              event.preventDefault();\n              break;\n            case 13: //enter\n              toggleDropDown();\n              break;\n          }\n          console.log(event.keyCode)\n        });\n\n        $scope.tsDropDown.forEach(function(dropDownItem){\n          $transclude($scope.$new(), function(clone, scope) {\n            scope.item = dropDownItem;\n\n            var listItem = angular.element(document.createElement('li'));\n            listItem.append(clone[0]);\n\n            listItem.on('click', function(){\n              updateSelected(dropDownItem);\n              $scope.$apply(toggleDropDown);\n            })\n            listItem[0].style.width=(textDisplayElement[0].offsetWidth-12)+'px';\n\n            dropDownUnorderedList.append(listItem);\n          }, null, 'listItem');\n        });\n\n        var placeholderElement, placeholderScope;\n\n        $transclude($scope.$new(), function(clone, scope){\n          placeholderScope = scope;\n          placeholderElement = clone[0];\n\n          textDisplayElement.append(clone[0]);\n        }, null, 'placeholder')\n\n\n        // Take the height of the window divided by 2 to get the middle of the window\n        // if the element's middle is lower than the middle of the window then open upward\n        // otherwise open downward\n        function toggleDropDown(){\n          var rect = $element[0].getBoundingClientRect();\n          var middleOfWindow = window.innerHeight/2;\n          var middleOfElement = rect.top+rect.height/2;\n\n          if(middleOfElement>middleOfWindow){\n            $scope.direction = 'up';\n\n            dropDownListContainer[0].style.bottom = rect.height+'px';\n            dropDownListContainer[0].style.top = 'auto';\n\n            //Flips the items in the list when opening upward\n            for (var i = 0; i < dropDownUnorderedList.children().length; i++) {\n              var childElement = dropDownUnorderedList.children()[i];\n              dropDownUnorderedList.prepend(childElement)\n            }\n          }\n          else{\n            dropDownListContainer[0].style.top = rect.height+'px';\n            dropDownListContainer[0].style.bottom = 'auto';\n            $scope.direction = 'down';\n          }\n\n          $scope.dropDownOpen = !$scope.dropDownOpen;\n        }\n\n        textDisplayElement.on('click', function(){\n          $scope.$apply(toggleDropDown)\n        });\n        dropDownArrow.on('click', function(){\n          $scope.$apply(toggleDropDown)\n        });\n\n        if (!ngModelCtrl) return; // do nothing if no ng-model\n\n        // Specify how UI should be updated\n        ngModelCtrl.$render = function() {\n          //update selected element text\n          updateSelected(ngModelCtrl.$viewValue || '');\n        };\n\n        function updateSelected(selectedValue){\n          placeholderScope.selectedItem = selectedItem = selectedValue;\n          $scope.$evalAsync(read);\n        }\n\n        // Listen for change events to enable binding\n        $element.on('blur keyup', function() {\n\n          $scope.$evalAsync(read);\n          ngModelCtrl.$render();\n        });\n        read(); // initialize\n\n        // Write data to the model\n        function read() {\n          ngModelCtrl.$setViewValue(selectedItem);\n        }\n      }\n\n    };\n  });\n","/**\n * autoGrow - Increases height of textarea while typing\n *\n * @note use with min-height, max-height and box-sizing:border-box\n *\n * @example\n * \t<textarea auto-grow></textarea>\n */\n angular.module('ts.utils').directive('autoGrow', function($timeout) {\n  return {\n    restrict: 'A',\n    link: function($scope, $element, $attrs) {\n      function grow() {\n        $element[0].style.height = 0; // autoshrink - need accurate scrollHeight\n        $element[0].style.height = $element[0].scrollHeight + 'px';\n      }\n      $element.on('input', grow);\n      $timeout(grow, true);\n    }\n  }\n});\n","(function(module) {\ntry {\n  module = angular.module('ts.utils');\n} catch (e) {\n  module = angular.module('ts.utils', []);\n}\nmodule.run(['$templateCache', function($templateCache) {\n  $templateCache.put('templates/tsDropDown.html',\n    '<div class=\"drop-down-container\">\\n' +\n    '  <div class=\"selected-item-container\">\\n' +\n    '  </div><div class=\"arrow-container\">\\n' +\n    '    <div ng-if=\"!dropDownOpen\" class=\"drop-down-arrow\"><i class=\"fa fa-angle-down\"></i></div>\\n' +\n    '    <div ng-if=\"dropDownOpen\" class=\"drop-down-arrow\"><i class=\"fa fa-angle-up\"></i></div>\\n' +\n    '  </div>\\n' +\n    '  <div ng-show=\"dropDownOpen\"\\n' +\n    '       class=\"drop-down-list-container\">\\n' +\n    '    <ul>\\n' +\n    '    </ul>\\n' +\n    '  </div>\\n' +\n    '</div>');\n}]);\n})();\n"],"sourceRoot":"/source/"}