{"version":3,"sources":["utils.min.js","utils.js","uiEvent.js","truncate.js","tooltip.js","scrollOn.js","focusOn.js","tsTooltip.js","dropDown.js","autoGrow.js","tsDropDown.js"],"names":["angular","module","directive","$parse","priority","link","$scope","$elm","$attrs","events","$eval","uiEvent","forEach","eventName","fn","bind","evt","params","Array","prototype","slice","call","arguments","splice","$event","$params","$$phase","$apply","filter","value","wordLimit","ellipses","length","undefined","isNumber","words","split","join","$templateCache","$compile","$window","restrict","scope","tsTooltip","tsTooltipDirection","tsTooltipEvent","tsTooltipShow","transclude","content","$element","$attr","$ctrl","$transclude","offset","elem","docElem","win","rect","doc","getBoundingClientRect","width","height","getClientRects","ownerDocument","documentElement","top","pageYOffset","clientTop","left","pageXOffset","clientLeft","makeVisible","isVisible","newTooltip","style","visibility","elementOffset","direction","origOffset","offsetHeight","tooltipMain","ARROW_SIZE","offsetWidth","makeInvisible","toggleVisibility","template","get","eventType","find","addClass","document","body","insertBefore","childNodes","clone","append","on","$watch","newVal","oldVal","$timeout","pre","$on","scrollOn","event","location","scrollTop","scrollHeight","focusOnConfig","listener","noop","$observe","speed","parents","targetWindow","animate","complete","focus","extraOffset","focusOnOffset","parseInt","autoCenter","focusOnAutoCenter","window","innerHeight","clientHeight","$","provider","_offset","_autoCenter","this","$get","e","run","put","require","listItem","placeholder","tsDropDownTemplate","tsDropDown","templateUrl","ngModelCtrl","moveHighlightDown","selectedIndex","hasOwnProperty","interactive","highlightedItem","moveHighlightUp","flipItems","i","dropDownUnorderedList","children","childElement","prepend","toggleDropDown","middleOfWindow","middleOfElement","dropDownListContainer","bottom","itemsFlipped","dropDownOpen","updateSelected","selectedValue","placeholderScope","selectedItem","$evalAsync","read","$setViewValue","ae","element","placeholderElement","container","textDisplayElement","dropDownArrow","querySelector","attr","keyCode","preventDefault","dropDownItem","$new","item","createElement","compiledListItem","indexOf","$render","$viewValue","grow"],"mappings":"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","file":"utils.min.js","sourcesContent":["'use strict';\n\nangular.module('ts.utils', []);\n/**\n * @TODO remove in liue of ui-utils\n * General-purpose Event binding. Bind any event not natively supported by Angular\n * Pass an object with keynames for events to ui-event\n * Allows $event object and $params object to be passed\n *\n * @example <input ui-event=\"{ focus : 'counter++', blur : 'someCallback()' }\">\n * @example <input ui-event=\"{ myCustomEvent : 'myEventHandler($event, $params)'}\">\n *\n * @param ui-event {string|object literal} The event to bind to as a string or a hash of events with their callbacks\n */\n'use strict';\n\nangular.module('ts.utils').directive('uiEvent', function ($parse) {\n    return {\n        priority: 100,\n        link: function link($scope, $elm, $attrs) {\n            var events = $scope.$eval($attrs.uiEvent);\n            angular.forEach(events, function (uiEvent, eventName) {\n                var fn = $parse(uiEvent);\n                $elm.bind(eventName, function (evt) {\n                    var params = Array.prototype.slice.call(arguments);\n                    //Take out first paramater (event object);\n                    params = params.splice(1);\n                    fn($scope, { $event: evt, $params: params });\n                    if (!$scope.$$phase) {\n                        $scope.$apply();\n                    }\n                });\n            });\n        }\n    };\n});\n/**\n * truncate - Truncates a string by a specified number of words\n *\n * @example\n * \t<p>\n * \t\t{{::post.body | truncate : 35}}\n * \t\t<a ng-if=\"::post.body.split(' ').length>35\">Read More</a>\n * \t</p>\n *\n * @param {string} value  The string to be truncated\n * @param {int} [wordLimit] The number of words to truncate at. If falsey, doesn't truncate.\n * @param {string} [ellipses] The string to use as an ellipses. Default: '…' (&hellip;)\n */\n'use strict';\n\nangular.module('ts.utils').filter('tsTruncate', function () {\n  return function (value, wordLimit) {\n    var ellipses = arguments.length <= 2 || arguments[2] === undefined ? '…' : arguments[2];\n\n    if (!value || !angular.isNumber(wordLimit)) return value;\n\n    var words = value.split(' ');\n\n    if (words.length > wordLimit) {\n      value = words.slice(0, wordLimit).join(' ');\n\n      if (ellipses) value += ellipses;\n    }\n\n    return value;\n  };\n});\n/**\n * ts-tooltip - Shows a tooltip with an arrow pointing to the element the directive is applied to.\n *\n * @note depends on jQuery\n *\n * @example\n *\n *<button\n *        ts-tooltip-event=\"click\"                              // Options are click or mouseover\n *        ts-tooltip=\"Something that shows up in there\"         // The text to show in the tooltip\n *        ts-tooltip-direction=\"bottom\"                         // The direction the tooltip pops up\n *        ts-tooltip-show=\"someModel.someBoolean\"               // A boolean if set will use this instead of events\n *        >\n *   Bottom Click Me\n * </button>\n *\n */\n\n'use strict';\n\nangular.module('ts.utils').directive('tsTooltip', function ($templateCache, $compile, $window) {\n\n  return {\n    restrict: 'A',\n    scope: {\n      tsTooltip: '@',\n      tsTooltipDirection: '@',\n      tsTooltipEvent: '@',\n      tsTooltipShow: '='\n    },\n    transclude: { content: '?tooltipContent' },\n    link: function link($scope, $element, $attr, $ctrl, $transclude) {\n      var ARROW_SIZE = 10;\n      var template = $templateCache.get('templates/tsTooltip.html');\n      var direction = $scope.tsTooltipDirection || 'right';\n      var eventType = $scope.tsTooltipEvent || 'mouseenter';\n      var isVisible = false;\n\n      var newTooltip = $compile(template)($scope);\n      newTooltip[0].style.visibility = 'hidden';\n\n      var tooltipMain = newTooltip.find(\"#tooltipMain\");\n      tooltipMain.addClass(direction);\n\n      // $element.after(newTooltip);\n      document.body.insertBefore(newTooltip[0], document.body.childNodes[0]);\n\n      // Puts back the original contents, we need to transclude to get compiled clones of the\n      // child called tooltip-content if its present below.\n      $transclude(function (clone, scope) {\n        $element.append(clone);\n      });\n\n      // Allows for <tooltip-content></tooltip-content> to be specified inside the element a\n      // tooltip applies to\n      $transclude(function (clone, scope) {\n        tooltipMain.append(clone);\n      }, null, 'content');\n\n      // Taken from jQuery so we don't have to directly depend on it for this\n      // calculates the top left offsets for a given element.\n      function offset(elem) {\n        var docElem, win, rect, doc;\n\n        if (!elem) {\n          return;\n        }\n\n        rect = elem.getBoundingClientRect();\n\n        // Make sure element is not hidden (display: none) or disconnected\n        if (rect.width || rect.height || elem.getClientRects().length) {\n          doc = elem.ownerDocument;\n          win = $window;\n          docElem = doc.documentElement;\n\n          return {\n            top: rect.top + win.pageYOffset - docElem.clientTop,\n            left: rect.left + win.pageXOffset - docElem.clientLeft\n          };\n        }\n      }\n\n      var origOffset = offset(newTooltip[0]);\n\n      function makeVisible() {\n        if (!isVisible) {\n\n          isVisible = true;\n\n          newTooltip[0].style.visibility = 'visible';\n\n          var elementOffset = offset($element[0]);\n\n          //Sets the common top for left and right, or common left for top and bottom\n          switch (direction) {\n            case 'right':\n            case 'left':\n              newTooltip[0].style.top = elementOffset.top - origOffset.top + $element[0].offsetHeight - tooltipMain[0].offsetHeight / 2 - ARROW_SIZE + 'px';\n              break;\n            case 'top':\n            case 'bottom':\n              newTooltip[0].style.left = elementOffset.left - origOffset.left + $element[0].offsetWidth / 2 - tooltipMain[0].offsetWidth / 2 + 'px';\n              break;\n          }\n\n          //Sets the specific left or top values for each direction\n          switch (direction) {\n            case 'right':\n              newTooltip[0].style.left = elementOffset.left - origOffset.left + $element[0].offsetWidth + ARROW_SIZE + 'px';\n              break;\n            case 'left':\n              newTooltip[0].style.left = elementOffset.left - origOffset.left - tooltipMain[0].offsetWidth - ARROW_SIZE + 'px';\n              break;\n            case 'top':\n              newTooltip[0].style.top = elementOffset.top - origOffset.top - tooltipMain[0].offsetHeight - ARROW_SIZE + 'px';\n              break;\n            case 'bottom':\n              newTooltip[0].style.top = elementOffset.top - origOffset.top + $element[0].offsetHeight + ARROW_SIZE + 'px';\n              break;\n          }\n        }\n      }\n\n      function makeInvisible() {\n        if (isVisible) {\n          isVisible = false;\n          newTooltip[0].style.visibility = 'hidden';\n        }\n      }\n\n      function toggleVisibility() {\n        if (isVisible) {\n          makeInvisible();\n        } else {\n          makeVisible();\n        }\n      }\n\n      if ($attr.tsTooltipShow === undefined) {\n        switch (eventType) {\n          case 'mouseenter':\n            $element.on('mouseenter', makeVisible);\n            $element.on('mouseleave', makeInvisible);\n            break;\n          case 'click':\n            $element.on('click', toggleVisibility);\n            break;\n        }\n      } else {\n        $scope.$watch('tsTooltipShow', function (newVal, oldVal) {\n          if (newVal) {\n            makeVisible();\n          } else {\n            makeInvisible();\n          }\n        });\n      }\n    }\n  };\n});\n\n// .directive('tooltipContent',function() {\n//   return {\n//     restrict:'E',\n//     compile:function(tElement,tAttrs) {\n\n//     }\n//   }\n// })\n\n/**\n * scrollOn - $broadcast()/$emit() a $scope event with the location to trigger scrolling\n *\n * @example\n *   <ul scroll-on=\"someEventName\" style=\"overflow: auto\">...</ul>\n *   ...\n *   var location = 'bottom';\n *   $scope.$broadcast('someEventName', location)\n *\n * @param location {'top'|'bottom'|offset} must be passed as event data\n */\n'use strict';\n\nangular.module('ts.utils').directive('scrollOn', function ($timeout) {\n  return {\n    link: {\n      pre: function pre($scope, $element, $attrs) {\n        $scope.$on($attrs.scrollOn, function (event, location) {\n          // let updates render\n          $timeout(function () {\n            if (location === 'bottom') {\n              $element[0].scrollTop = $element[0].scrollHeight;\n            } else if (location === 'top') {\n              $element[0].scrollTop = 0;\n            } else {\n              $element[0].scrollTop = location;\n            }\n          }, true);\n        });\n      }\n    }\n  };\n});\n/**\n * focusOn - Focuses an input on scope event\n *\n * @note depends on jQuery\n *\n * @example\n *   <input focus-on=\"someEventName\">\n *   or\n *   <input focus-on=\"focus-row-{{$index}}\">\n *   or\n *   <p focus-on=\"anotherEvent\"></p>\n *   ...\n *   $scope.$broadcast('someEventName');\n *   $scope.$broadcast('focus-row-2');\n *   $scope.$broadcast('anotherEvent');\n *\n *   focusOnConfigProvider - can be injected into a .config(function(focusOnConfigProvider){}) block to configure the\n *   app wide settings for the focusOn directive\n *\n *   Settings include:\n *      offset - number of pixels to offset the scroll to for a header or other info that appears above the element you\n *      want to scroll to the top of the screen.  The offset is subtracted from the computed scroll position\n *\n *      autoCenter - boolean if true will use the element height and document body height to scroll the element to the\n *      center of the screen instead of the top\n *\n *   App wide settings can be overridden using attributes along with the focus-on directive.  The attributes for the\n *   offset and autoCenter are focus-on-offset and focus-on-auto-center respectively.\n *\n */\n'use strict';\n\nangular.module('ts.utils').directive('focusOn', function ($window, focusOnConfig) {\n  return {\n    link: function link($scope, $element, $attrs) {\n      var listener = angular.noop;\n      $attrs.$observe('focusOn', function (newVal) {\n        // Stop listening to old event name\n        listener();\n        // Listen to new event name\n        listener = $scope.$on(newVal, function (speed) {\n          speed = speed || 1000;\n          // Center element on screen\n          if ($element.parents('.reveal-modal').length) {\n            var targetWindow = $element.parents('.reveal-modal .content');\n            targetWindow.animate({\n              scrollTop: $element.offset().top - targetWindow.offset().top + targetWindow.scrollTop()\n            }, {\n              speed: speed,\n              complete: function complete() {\n                // Focus element (if input)\n                $element[0].focus();\n              }\n            });\n          } else {\n            var offset = $element.offset().top;\n\n            // Use provider configured offset\n            var extraOffset = focusOnConfig.offset;\n\n            // If attribute is set override provider configured offset\n            if ($attrs.focusOnOffset !== undefined) {\n              extraOffset = parseInt($attrs.focusOnOffset);\n            }\n\n            // Check if provider or attribute set autoCenter/auto-center to true if so use offset/2 ignores the extra\n            // offset in this case\n            if (focusOnConfig.autoCenter && $attrs.focusOnAutoCenter === undefined || $attrs.focusOnAutoCenter && $attrs.focusOnAutoCenter == 'true') {\n              offset = offset - window.innerHeight / 2 - $element[0].clientHeight / 2;\n            } else {\n              offset = offset - extraOffset;\n            }\n\n            $('body').animate({ scrollTop: offset }, {\n              speed: speed,\n              complete: function complete() {\n                // Focus element (if input)\n                $element[0].focus();\n              }\n            });\n          }\n        });\n      });\n    }\n  };\n}).provider('focusOnConfig', function () {\n  var _offset = 0;\n  var _autoCenter = false;\n\n  this.autoCenter = function (value) {\n    _autoCenter = value;\n  };\n\n  this.offset = function (value) {\n    _offset = value;\n  };\n\n  this.$get = function () {\n    return {\n      offset: _offset,\n      autoCenter: _autoCenter\n    };\n  };\n});\n'use strict';\n\n(function (module) {\n  try {\n    module = angular.module('ts.utils');\n  } catch (e) {\n    module = angular.module('ts.utils', []);\n  }\n  module.run(['$templateCache', function ($templateCache) {\n    $templateCache.put('templates/tsTooltip.html', '<div class=\"ts-tooltip-container\">\\n' + '  <div class=\"arrow-box-container\">\\n' + '    <div id=\"tooltipMain\" class=\"ts-tooltip-main\">\\n' + '      {{tsTooltip}}\\n' + '    </div>\\n' + '  </div>\\n' + '</div>');\n  }]);\n})();\n/**\n * ts-dropwdown - Shows a drop down list of items that can be selected from.\n *\n * @note depends on jQuery\n *\n * @example\n *\n *\n */\n\n'use strict';\nangular.module('ts.utils').directive('tsDropDown', function ($templateCache, $compile) {\n\n  return {\n    restrict: 'A',\n    require: 'ngModel',\n    transclude: {\n      'listItem': 'tsListItem',\n      'placeholder': 'tsPlaceholder'\n    },\n    scope: {\n      tsDropDownTemplate: '@',\n      tsDropDown: '='\n    },\n\n    templateUrl: 'templates/tsDropDown.html',\n\n    link: function link($scope, $element, $attr, ngModelCtrl, $transclude) {\n      var selectedIndex = 0,\n          itemsFlipped = false,\n          ae = angular.element,\n          //shorthand\n      placeholderElement = undefined,\n          placeholderScope = undefined,\n          selectedItem = undefined,\n          container = ae($element.children()[0]),\n          //Container for all the drop down related parts\n      textDisplayElement = ae(container.children()[0]),\n          //First child of the container is the place to put the placeholder or selected item\n      dropDownArrow = ae(container.children()[1]),\n          //Second child is the drop down arrow/button\n      dropDownListContainer = ae(container.children()[2]),\n          //Third child is the list container\n      dropDownUnorderedList = ae($element[0].querySelector('ul'));\n\n      //Makes the element focusable with the keyboard\n      $element.attr('tabindex', '0');\n\n      $scope.direction = 'down';\n      $scope.dropDownOpen = false;\n\n      $element.on('keydown', function (event) {\n        switch (event.keyCode) {\n          case 13:\n            //enter\n            updateSelected($scope.highlightedItem);\n            toggleDropDown();\n            event.preventDefault();\n            break;\n\n          case 38:\n            //up\n\n            // If list isn't open, open it\n            if (!$scope.dropDownOpen) {\n              toggleDropDown();\n            } else {\n              // otherwise if the list is open move up in the highlights.\n              $scope.$apply($scope.direction == 'down' ? moveHighlightUp : moveHighlightDown);\n            }\n            event.preventDefault();\n            break;\n\n          case 40:\n            //down\n\n            //If list isn't open, open it\n            if (!$scope.dropDownOpen) {\n              toggleDropDown();\n            } else {\n              $scope.$apply($scope.direction == 'down' ? moveHighlightDown : moveHighlightUp);\n            }\n            event.preventDefault();\n            break;\n        }\n      });\n\n      function moveHighlightDown() {\n        while ($scope.tsDropDown.length - 1 > selectedIndex) {\n          selectedIndex++;\n          if (!$scope.tsDropDown[selectedIndex].hasOwnProperty('interactive') || $scope.tsDropDown[selectedIndex].interactive === true) break;\n        }\n        $scope.highlightedItem = $scope.tsDropDown[selectedIndex];\n      }\n\n      function moveHighlightUp() {\n        while (0 < selectedIndex) {\n          selectedIndex--;\n          if (!$scope.tsDropDown[selectedIndex].hasOwnProperty('interactive') || $scope.tsDropDown[selectedIndex].interactive === true) break;\n        }\n        $scope.highlightedItem = $scope.tsDropDown[selectedIndex];\n      }\n\n      $scope.tsDropDown.forEach(function (dropDownItem) {\n        $transclude($scope.$new(), function (clone, scope) {\n          scope.item = dropDownItem;\n\n          var listItem = ae(document.createElement('li'));\n          listItem.attr('ng-class', '{\"highlighted\":highlightedItem==item}');\n          var compiledListItem = $compile(listItem)(scope);\n          compiledListItem.append(clone[0]);\n\n          if (!dropDownItem.hasOwnProperty('interactive') || dropDownItem.interactive === true) {\n            compiledListItem.on('click', function () {\n              updateSelected(dropDownItem);\n              $scope.$apply(toggleDropDown);\n            });\n            compiledListItem.on('mouseenter', function () {\n              $scope.highlightedItem = scope.item;\n              selectedIndex = $scope.tsDropDown.indexOf(scope.item);\n              $scope.$apply();\n            });\n          }\n\n          compiledListItem[0].style.width = textDisplayElement[0].offsetWidth - 12 + 'px';\n\n          dropDownUnorderedList.append(compiledListItem);\n        }, null, 'listItem');\n      });\n\n      //Initialize to first item is highlighted\n      $scope.highlightedItem = $scope.tsDropDown[selectedIndex];\n\n      $transclude($scope.$new(), function (clone, scope) {\n        placeholderScope = scope;\n        placeholderElement = clone[0];\n\n        textDisplayElement.append(clone[0]);\n      }, null, 'placeholder');\n\n      function flipItems() {\n\n        //Flips the items in the list when opening upward\n        for (var i = 0; i < dropDownUnorderedList.children().length; i++) {\n          var childElement = dropDownUnorderedList.children()[i];\n          dropDownUnorderedList.prepend(childElement);\n        }\n      }\n\n      // Take the height of the window divided by 2 to get the middle of the window\n      // if the element's middle is lower than the middle of the window then open upward\n      // otherwise open downward\n      function toggleDropDown() {\n        var rect = $element[0].getBoundingClientRect();\n        var middleOfWindow = window.innerHeight / 2;\n        var middleOfElement = rect.top + rect.height / 2;\n\n        if (middleOfElement > middleOfWindow) {\n          $scope.direction = 'up';\n\n          dropDownListContainer[0].style.bottom = rect.height + 'px';\n          dropDownListContainer[0].style.top = 'auto';\n          if (!itemsFlipped) {\n            flipItems();\n            itemsFlipped = true;\n          }\n        } else {\n          dropDownListContainer[0].style.top = rect.height + 'px';\n          dropDownListContainer[0].style.bottom = 'auto';\n          $scope.direction = 'down';\n\n          if (itemsFlipped) {\n            flipItems();\n            itemsFlipped = false;\n          }\n        }\n\n        $scope.dropDownOpen = !$scope.dropDownOpen;\n      }\n\n      textDisplayElement.on('click', function () {\n        $scope.$apply(toggleDropDown);\n      });\n      dropDownArrow.on('click', function () {\n        $scope.$apply(toggleDropDown);\n      });\n\n      if (!ngModelCtrl) return; // do nothing if no ng-model\n\n      function updateSelected(selectedValue) {\n        placeholderScope.selectedItem = selectedItem = selectedValue;\n        $scope.$evalAsync(read);\n      }\n\n      $element.on('blur', function () {\n        $scope.$apply(function () {\n          $scope.dropDownOpen = false;\n        });\n      });\n\n      // Specify how UI should be updated when the model changes from outside\n      ngModelCtrl.$render = function () {\n        //update selected element text\n        updateSelected(ngModelCtrl.$viewValue || '');\n      };\n\n      // Write data to the model\n      function read() {\n        ngModelCtrl.$setViewValue(selectedItem);\n      }\n    }\n\n  };\n});\n/**\n * autoGrow - Increases height of textarea while typing\n *\n * @note use with min-height, max-height and box-sizing:border-box\n *\n * @example\n * \t<textarea auto-grow></textarea>\n */\n'use strict';\n\nangular.module('ts.utils').directive('autoGrow', function ($timeout) {\n  return {\n    restrict: 'A',\n    link: function link($scope, $element, $attrs) {\n      function grow() {\n        $element[0].style.height = 0; // autoshrink - need accurate scrollHeight\n        $element[0].style.height = $element[0].scrollHeight + 'px';\n      }\n      $element.on('input', grow);\n      $timeout(grow, true);\n    }\n  };\n});\n'use strict';\n\n(function (module) {\n  try {\n    module = angular.module('ts.utils');\n  } catch (e) {\n    module = angular.module('ts.utils', []);\n  }\n  module.run(['$templateCache', function ($templateCache) {\n    $templateCache.put('templates/tsDropDown.html', '<div class=\"drop-down-container\">\\n' + '  <div class=\"selected-item-container\">\\n' + '  </div><div class=\"arrow-container\">\\n' + '    <div ng-if=\"!dropDownOpen\" class=\"drop-down-arrow\"><i class=\"fa fa-angle-down\"></i></div>\\n' + '    <div ng-if=\"dropDownOpen\" class=\"drop-down-arrow\"><i class=\"fa fa-angle-up\"></i></div>\\n' + '  </div>\\n' + '  <div ng-show=\"dropDownOpen\"\\n' + '       class=\"drop-down-list-container\">\\n' + '    <ul>\\n' + '    </ul>\\n' + '  </div>\\n' + '</div>');\n  }]);\n})();","angular.module('ts.utils', []);\n","/**\n * @TODO remove in liue of ui-utils\n * General-purpose Event binding. Bind any event not natively supported by Angular\n * Pass an object with keynames for events to ui-event\n * Allows $event object and $params object to be passed\n *\n * @example <input ui-event=\"{ focus : 'counter++', blur : 'someCallback()' }\">\n * @example <input ui-event=\"{ myCustomEvent : 'myEventHandler($event, $params)'}\">\n *\n * @param ui-event {string|object literal} The event to bind to as a string or a hash of events with their callbacks\n */\nangular.module('ts.utils').directive('uiEvent', function ($parse) {\n    return {\n        priority: 100,\n        link: function ($scope, $elm, $attrs) {\n            var events = $scope.$eval($attrs.uiEvent);\n            angular.forEach(events, function (uiEvent, eventName) {\n                var fn = $parse(uiEvent);\n                $elm.bind(eventName, function (evt) {\n                    var params = Array.prototype.slice.call(arguments);\n                    //Take out first paramater (event object);\n                    params = params.splice(1);\n                    fn($scope, {$event: evt, $params: params});\n                    if (!$scope.$$phase) {\n                        $scope.$apply();\n                    }\n                });\n            });\n        }\n    };\n});\n","/**\n * truncate - Truncates a string by a specified number of words\n *\n * @example\n * \t<p>\n * \t\t{{::post.body | truncate : 35}}\n * \t\t<a ng-if=\"::post.body.split(' ').length>35\">Read More</a>\n * \t</p>\n *\n * @param {string} value  The string to be truncated\n * @param {int} [wordLimit] The number of words to truncate at. If falsey, doesn't truncate.\n * @param {string} [ellipses] The string to use as an ellipses. Default: '…' (&hellip;)\n */\n angular.module('ts.utils').filter('tsTruncate', function() {\n  return function(value, wordLimit, ellipses = '…'){\n    if (!value || !angular.isNumber(wordLimit))\n      return value;\n\n    var words = value.split(' ');\n\n    if (words.length > wordLimit) {\n      value = words.slice(0, wordLimit).join(' ');\n\n      if (ellipses)\n        value += ellipses;\n    }\n\n    return value;\n  }\n});\n","/**\n * ts-tooltip - Shows a tooltip with an arrow pointing to the element the directive is applied to.\n *\n * @note depends on jQuery\n *\n * @example\n *\n *<button\n *        ts-tooltip-event=\"click\"                              // Options are click or mouseover\n *        ts-tooltip=\"Something that shows up in there\"         // The text to show in the tooltip\n *        ts-tooltip-direction=\"bottom\"                         // The direction the tooltip pops up\n *        ts-tooltip-show=\"someModel.someBoolean\"               // A boolean if set will use this instead of events\n *        >\n *   Bottom Click Me\n * </button>\n *\n */\n\n\nangular.module('ts.utils')\n\n  .directive('tsTooltip', function($templateCache, $compile, $window){\n\n    return {\n      restrict:'A',\n      scope:{\n        tsTooltip:'@',\n        tsTooltipDirection:'@',\n        tsTooltipEvent:'@',\n        tsTooltipShow:'='\n      },\n      transclude:{content:'?tooltipContent'},\n      link: function($scope, $element, $attr, $ctrl, $transclude) {\n        var ARROW_SIZE = 10;\n        var template = $templateCache.get('templates/tsTooltip.html');\n        var direction = $scope.tsTooltipDirection || 'right';\n        var eventType = $scope.tsTooltipEvent || 'mouseenter';\n        var isVisible = false;\n\n        var newTooltip = $compile(template)($scope);\n        newTooltip[0].style.visibility = 'hidden';\n\n        var tooltipMain = newTooltip.find(\"#tooltipMain\");\n        tooltipMain.addClass(direction);\n\n        // $element.after(newTooltip);\n        document.body.insertBefore(newTooltip[0],document.body.childNodes[0]);\n\n        // Puts back the original contents, we need to transclude to get compiled clones of the\n        // child called tooltip-content if its present below.\n        $transclude(function(clone, scope) {\n          $element.append(clone);\n        });\n\n        // Allows for <tooltip-content></tooltip-content> to be specified inside the element a\n        // tooltip applies to\n        $transclude(function(clone, scope) {\n          tooltipMain.append(clone);\n        }, null, 'content');\n\n\n        // Taken from jQuery so we don't have to directly depend on it for this\n        // calculates the top left offsets for a given element.\n        function offset( elem ) {\n          var docElem, win, rect, doc;\n\n          if ( !elem ) {\n            return;\n          }\n\n          rect = elem.getBoundingClientRect();\n\n          // Make sure element is not hidden (display: none) or disconnected\n          if ( rect.width || rect.height || elem.getClientRects().length ) {\n            doc = elem.ownerDocument;\n            win = $window;\n            docElem = doc.documentElement;\n\n            return {\n              top: rect.top + win.pageYOffset - docElem.clientTop,\n              left: rect.left + win.pageXOffset - docElem.clientLeft\n            };\n          }\n        }\n\n        var origOffset = offset(newTooltip[0]);\n\n        function makeVisible(){\n          if(!isVisible){\n\n            isVisible = true;\n\n            newTooltip[0].style.visibility='visible';\n\n            var elementOffset = offset($element[0]);\n\n            //Sets the common top for left and right, or common left for top and bottom\n            switch(direction){\n              case 'right':\n              case 'left':\n                newTooltip[0].style.top=(elementOffset.top-origOffset.top+$element[0].offsetHeight - tooltipMain[0].offsetHeight/2-ARROW_SIZE)+'px';\n                break;\n              case 'top':\n              case 'bottom':\n                newTooltip[0].style.left=elementOffset.left-origOffset.left+$element[0].offsetWidth/2-tooltipMain[0].offsetWidth/2+'px';\n                break;\n            }\n\n            //Sets the specific left or top values for each direction\n            switch(direction) {\n              case 'right':\n                newTooltip[0].style.left=elementOffset.left-origOffset.left+$element[0].offsetWidth+ARROW_SIZE+'px';\n                break;\n              case 'left':\n                newTooltip[0].style.left=(elementOffset.left-origOffset.left-tooltipMain[0].offsetWidth - ARROW_SIZE )+'px';\n                break;\n              case 'top':\n                newTooltip[0].style.top=elementOffset.top-origOffset.top - tooltipMain[0].offsetHeight-ARROW_SIZE+ 'px';\n                break;\n              case 'bottom':\n                newTooltip[0].style.top=elementOffset.top-origOffset.top + $element[0].offsetHeight+ARROW_SIZE+ 'px';\n                break;\n            }\n\n          }\n        }\n\n        function makeInvisible() {\n          if(isVisible){\n            isVisible = false;\n            newTooltip[0].style.visibility = 'hidden';\n          }\n        }\n\n        function toggleVisibility(){\n          if(isVisible) {\n            makeInvisible();\n          }\n          else {\n            makeVisible();\n          }\n        }\n\n        if($attr.tsTooltipShow === undefined) {\n          switch(eventType) {\n            case 'mouseenter':\n              $element.on('mouseenter', makeVisible);\n              $element.on('mouseleave', makeInvisible);\n              break;\n            case 'click':\n              $element.on('click', toggleVisibility);\n              break;\n          }\n        }\n        else{\n          $scope.$watch('tsTooltipShow',function(newVal, oldVal) {\n            if(newVal) {\n              makeVisible();\n            }\n            else {\n              makeInvisible();\n            }\n          })\n        }\n\n\n\n\n      }\n    };\n  })\n  // .directive('tooltipContent',function() {\n  //   return {\n  //     restrict:'E',\n  //     compile:function(tElement,tAttrs) {\n\n  //     }\n  //   }\n  // })\n;\n","\n/**\n * scrollOn - $broadcast()/$emit() a $scope event with the location to trigger scrolling\n *\n * @example\n *   <ul scroll-on=\"someEventName\" style=\"overflow: auto\">...</ul>\n *   ...\n *   var location = 'bottom';\n *   $scope.$broadcast('someEventName', location)\n *\n * @param location {'top'|'bottom'|offset} must be passed as event data\n */\nangular.module('ts.utils').directive('scrollOn', function($timeout) {\n  return {\n    link: {\n      pre: function($scope, $element, $attrs) {\n        $scope.$on($attrs.scrollOn, function(event, location){\n          // let updates render\n          $timeout(function(){\n            if (location === 'bottom') {\n              $element[0].scrollTop = $element[0].scrollHeight;\n            }\n            else if (location === 'top') {\n              $element[0].scrollTop = 0;\n            }\n            else {\n              $element[0].scrollTop = location;\n            }\n          }, true);\n        });\n      }\n    }\n  };\n});\n","/**\n * focusOn - Focuses an input on scope event\n *\n * @note depends on jQuery\n *\n * @example\n *   <input focus-on=\"someEventName\">\n *   or\n *   <input focus-on=\"focus-row-{{$index}}\">\n *   or\n *   <p focus-on=\"anotherEvent\"></p>\n *   ...\n *   $scope.$broadcast('someEventName');\n *   $scope.$broadcast('focus-row-2');\n *   $scope.$broadcast('anotherEvent');\n *\n *   focusOnConfigProvider - can be injected into a .config(function(focusOnConfigProvider){}) block to configure the\n *   app wide settings for the focusOn directive\n *\n *   Settings include:\n *      offset - number of pixels to offset the scroll to for a header or other info that appears above the element you\n *      want to scroll to the top of the screen.  The offset is subtracted from the computed scroll position\n *\n *      autoCenter - boolean if true will use the element height and document body height to scroll the element to the\n *      center of the screen instead of the top\n *\n *   App wide settings can be overridden using attributes along with the focus-on directive.  The attributes for the\n *   offset and autoCenter are focus-on-offset and focus-on-auto-center respectively.\n *\n */\n angular.module('ts.utils').directive('focusOn', function($window, focusOnConfig){\n  return {\n    link: function($scope, $element, $attrs) {\n      var listener = angular.noop;\n      $attrs.$observe('focusOn', function(newVal){\n        // Stop listening to old event name\n        listener();\n        // Listen to new event name\n        listener = $scope.$on(newVal, function(speed){\n          speed = speed || 1000;\n          // Center element on screen\n          if($element.parents('.reveal-modal').length) {\n            var targetWindow = $element.parents('.reveal-modal .content');\n            targetWindow.animate({\n              scrollTop: $element.offset().top - targetWindow.offset().top + targetWindow.scrollTop()\n            }, {\n              speed: speed,\n              complete: function complete() {\n                // Focus element (if input)\n                $element[0].focus();\n              }\n            });\n          }\n          else {\n            var offset = $element.offset().top;\n\n            // Use provider configured offset\n            var extraOffset = focusOnConfig.offset;\n\n            // If attribute is set override provider configured offset\n            if($attrs.focusOnOffset !== undefined){\n              extraOffset = parseInt($attrs.focusOnOffset);\n            }\n\n            // Check if provider or attribute set autoCenter/auto-center to true if so use offset/2 ignores the extra\n            // offset in this case\n            if( (focusOnConfig.autoCenter && $attrs.focusOnAutoCenter===undefined ) ||\n                ($attrs.focusOnAutoCenter && $attrs.focusOnAutoCenter=='true') ) {\n              offset = offset - window.innerHeight/2 - $element[0].clientHeight/2;\n            }\n            else{\n              offset = offset - extraOffset;\n            }\n\n            $('body').animate({ scrollTop: offset }, {\n              speed: speed,\n              complete: function complete() {\n                // Focus element (if input)\n                $element[0].focus();\n              }\n            });\n          }\n        });\n      });\n    }\n  };\n})\n\n.provider('focusOnConfig', function(){\n  var _offset = 0;\n  var _autoCenter = false;\n\n  this.autoCenter = function(value){\n    _autoCenter = value;\n  };\n\n  this.offset = function(value){\n    _offset = value;\n  };\n\n  this.$get = function(){\n    return {\n      offset: _offset,\n      autoCenter:_autoCenter\n    };\n  };\n\n});\n","(function(module) {\ntry {\n  module = angular.module('ts.utils');\n} catch (e) {\n  module = angular.module('ts.utils', []);\n}\nmodule.run(['$templateCache', function($templateCache) {\n  $templateCache.put('templates/tsTooltip.html',\n    '<div class=\"ts-tooltip-container\">\\n' +\n    '  <div class=\"arrow-box-container\">\\n' +\n    '    <div id=\"tooltipMain\" class=\"ts-tooltip-main\">\\n' +\n    '      {{tsTooltip}}\\n' +\n    '    </div>\\n' +\n    '  </div>\\n' +\n    '</div>');\n}]);\n})();\n","/**\n * ts-dropwdown - Shows a drop down list of items that can be selected from.\n *\n * @note depends on jQuery\n *\n * @example\n *\n *\n */\n\n'use strict';\nangular.module('ts.utils')\n\n  .directive('tsDropDown', function($templateCache, $compile) {\n\n    return {\n      restrict:'A',\n      require: 'ngModel',\n      transclude: {\n        'listItem':'tsListItem',\n        'placeholder':'tsPlaceholder'\n      },\n      scope:{\n        tsDropDownTemplate:'@',\n        tsDropDown: '='\n      },\n\n      templateUrl:'templates/tsDropDown.html',\n\n      link: function($scope, $element, $attr, ngModelCtrl, $transclude) {\n        let selectedIndex = 0,\n            itemsFlipped = false,\n            ae = angular.element, //shorthand\n            placeholderElement,\n            placeholderScope,\n            selectedItem,\n            container = ae($element.children()[0]), //Container for all the drop down related parts\n            textDisplayElement = ae(container.children()[0]), //First child of the container is the place to put the placeholder or selected item\n            dropDownArrow = ae(container.children()[1]), //Second child is the drop down arrow/button\n            dropDownListContainer = ae(container.children()[2]), //Third child is the list container\n            dropDownUnorderedList = ae($element[0].querySelector('ul'));\n\n        //Makes the element focusable with the keyboard\n        $element.attr('tabindex','0');\n\n        $scope.direction = 'down';\n        $scope.dropDownOpen = false;\n\n        $element.on('keydown', function(event) {\n          switch(event.keyCode){\n            case 13: //enter\n              updateSelected($scope.highlightedItem);\n              toggleDropDown();\n              event.preventDefault();\n              break;\n\n            case 38: //up\n\n              // If list isn't open, open it\n              if(!$scope.dropDownOpen) {\n                toggleDropDown();\n              }\n              else { // otherwise if the list is open move up in the highlights.\n                $scope.$apply($scope.direction=='down'?moveHighlightUp:moveHighlightDown);\n              }\n              event.preventDefault();\n              break;\n\n            case 40: //down\n\n              //If list isn't open, open it\n              if(!$scope.dropDownOpen) {\n                toggleDropDown();\n              } else {\n                $scope.$apply($scope.direction=='down'?moveHighlightDown:moveHighlightUp);\n              }\n              event.preventDefault();\n              break;\n          }\n        });\n\n        function moveHighlightDown() {\n          while($scope.tsDropDown.length-1>selectedIndex) {\n            selectedIndex++;\n            if( !$scope.tsDropDown[selectedIndex].hasOwnProperty('interactive') ||\n                $scope.tsDropDown[selectedIndex].interactive === true)\n              break;\n          }\n          $scope.highlightedItem = $scope.tsDropDown[selectedIndex];\n        }\n\n        function moveHighlightUp() {\n          while(0<selectedIndex) {\n            selectedIndex--;\n            if( !$scope.tsDropDown[selectedIndex].hasOwnProperty('interactive') ||\n                $scope.tsDropDown[selectedIndex].interactive === true)\n              break;\n          }\n          $scope.highlightedItem = $scope.tsDropDown[selectedIndex];\n        }\n\n        $scope.tsDropDown.forEach(function(dropDownItem) {\n          $transclude($scope.$new(), function(clone, scope) {\n            scope.item = dropDownItem;\n\n            var listItem = ae(document.createElement('li'));\n            listItem.attr('ng-class', '{\"highlighted\":highlightedItem==item}');\n            var compiledListItem = $compile(listItem)(scope);\n            compiledListItem.append(clone[0]);\n\n            if( !dropDownItem.hasOwnProperty('interactive') ||\n                dropDownItem.interactive === true) {\n              compiledListItem.on('click', function() {\n                updateSelected(dropDownItem);\n                $scope.$apply(toggleDropDown);\n              });\n              compiledListItem.on('mouseenter', function(){\n                $scope.highlightedItem = scope.item;\n                selectedIndex = $scope.tsDropDown.indexOf(scope.item);\n                $scope.$apply();\n              });\n\n            }\n\n            compiledListItem[0].style.width=(textDisplayElement[0].offsetWidth-12)+'px';\n\n            dropDownUnorderedList.append(compiledListItem);\n          }, null, 'listItem');\n        });\n\n        //Initialize to first item is highlighted\n        $scope.highlightedItem = $scope.tsDropDown[selectedIndex];\n\n        $transclude($scope.$new(), function(clone, scope){\n          placeholderScope = scope;\n          placeholderElement = clone[0];\n\n          textDisplayElement.append(clone[0]);\n        }, null, 'placeholder');\n\n        function flipItems(){\n\n          //Flips the items in the list when opening upward\n          for (var i = 0; i < dropDownUnorderedList.children().length; i++) {\n            var childElement = dropDownUnorderedList.children()[i];\n            dropDownUnorderedList.prepend(childElement)\n          }\n        }\n\n        // Take the height of the window divided by 2 to get the middle of the window\n        // if the element's middle is lower than the middle of the window then open upward\n        // otherwise open downward\n        function toggleDropDown(){\n          var rect = $element[0].getBoundingClientRect();\n          var middleOfWindow = window.innerHeight/2;\n          var middleOfElement = rect.top+rect.height/2;\n\n          if(middleOfElement>middleOfWindow){\n            $scope.direction = 'up';\n\n            dropDownListContainer[0].style.bottom = rect.height+'px';\n            dropDownListContainer[0].style.top = 'auto';\n            if(!itemsFlipped){\n              flipItems();\n              itemsFlipped = true;\n            }\n          }\n          else{\n            dropDownListContainer[0].style.top = rect.height+'px';\n            dropDownListContainer[0].style.bottom = 'auto';\n            $scope.direction = 'down';\n\n            if(itemsFlipped){\n              flipItems();\n              itemsFlipped = false;\n            }\n          }\n\n          $scope.dropDownOpen = !$scope.dropDownOpen;\n        }\n\n        textDisplayElement.on('click', function(){\n          $scope.$apply(toggleDropDown)\n        });\n        dropDownArrow.on('click', function(){\n          $scope.$apply(toggleDropDown)\n        });\n\n        if (!ngModelCtrl) return; // do nothing if no ng-model\n\n        function updateSelected(selectedValue){\n          placeholderScope.selectedItem = selectedItem = selectedValue;\n          $scope.$evalAsync(read);\n        }\n\n\n        $element.on('blur', function(){\n          $scope.$apply(function(){\n            $scope.dropDownOpen = false;\n          });\n        });\n\n        // Specify how UI should be updated when the model changes from outside\n        ngModelCtrl.$render = function() {\n          //update selected element text\n          updateSelected(ngModelCtrl.$viewValue || '');\n        };\n\n        // Write data to the model\n        function read() {\n          ngModelCtrl.$setViewValue(selectedItem);\n        }\n      }\n\n    };\n  });\n","/**\n * autoGrow - Increases height of textarea while typing\n *\n * @note use with min-height, max-height and box-sizing:border-box\n *\n * @example\n * \t<textarea auto-grow></textarea>\n */\n angular.module('ts.utils').directive('autoGrow', function($timeout) {\n  return {\n    restrict: 'A',\n    link: function($scope, $element, $attrs) {\n      function grow() {\n        $element[0].style.height = 0; // autoshrink - need accurate scrollHeight\n        $element[0].style.height = $element[0].scrollHeight + 'px';\n      }\n      $element.on('input', grow);\n      $timeout(grow, true);\n    }\n  }\n});\n","(function(module) {\ntry {\n  module = angular.module('ts.utils');\n} catch (e) {\n  module = angular.module('ts.utils', []);\n}\nmodule.run(['$templateCache', function($templateCache) {\n  $templateCache.put('templates/tsDropDown.html',\n    '<div class=\"drop-down-container\">\\n' +\n    '  <div class=\"selected-item-container\">\\n' +\n    '  </div><div class=\"arrow-container\">\\n' +\n    '    <div ng-if=\"!dropDownOpen\" class=\"drop-down-arrow\"><i class=\"fa fa-angle-down\"></i></div>\\n' +\n    '    <div ng-if=\"dropDownOpen\" class=\"drop-down-arrow\"><i class=\"fa fa-angle-up\"></i></div>\\n' +\n    '  </div>\\n' +\n    '  <div ng-show=\"dropDownOpen\"\\n' +\n    '       class=\"drop-down-list-container\">\\n' +\n    '    <ul>\\n' +\n    '    </ul>\\n' +\n    '  </div>\\n' +\n    '</div>');\n}]);\n})();\n"],"sourceRoot":"/source/"}