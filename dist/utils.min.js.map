{"version":3,"sources":["utils.min.js","utils.js","uiEvent.js","truncate.js","tooltip.js","scrollOn.js","focusOn.js","autoGrow.js"],"names":["angular","module","directive","$parse","priority","link","$scope","$elm","$attrs","events","$eval","uiEvent","forEach","eventName","fn","bind","evt","params","Array","prototype","slice","call","arguments","splice","$event","$params","$$phase","$apply","filter","value","wordLimit","ellipses","length","undefined","isNumber","words","split","join","$templateCache","$compile","restrict","scope","tsTooltip","tsTooltipDirection","tsTooltipEvent","tsTooltipShow","$element","makeVisible","isVisible","newTooltip","style","visibility","direction","left","top","children","offsetHeight","offsetWidth","makeInvisible","toggleVisibility","template","get","eventType","tooltipMain","find","addClass","after","on","$watch","newVal","oldVal","$timeout","pre","$on","scrollOn","event","location","scrollTop","scrollHeight","$window","focusOnConfig","listener","noop","$observe","speed","parents","targetWindow","animate","offset","complete","focus","extraOffset","focusOnOffset","parseInt","autoCenter","focusOnAutoCenter","window","innerHeight","clientHeight","$","provider","_offset","_autoCenter","this","$get","grow","height"],"mappings":"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","file":"utils.min.js","sourcesContent":["'use strict';\n\nangular.module('ts.utils', []);\n/**\n * @TODO remove in liue of ui-utils\n * General-purpose Event binding. Bind any event not natively supported by Angular\n * Pass an object with keynames for events to ui-event\n * Allows $event object and $params object to be passed\n *\n * @example <input ui-event=\"{ focus : 'counter++', blur : 'someCallback()' }\">\n * @example <input ui-event=\"{ myCustomEvent : 'myEventHandler($event, $params)'}\">\n *\n * @param ui-event {string|object literal} The event to bind to as a string or a hash of events with their callbacks\n */\n'use strict';\n\nangular.module('ts.utils').directive('uiEvent', function ($parse) {\n    return {\n        priority: 100,\n        link: function link($scope, $elm, $attrs) {\n            var events = $scope.$eval($attrs.uiEvent);\n            angular.forEach(events, function (uiEvent, eventName) {\n                var fn = $parse(uiEvent);\n                $elm.bind(eventName, function (evt) {\n                    var params = Array.prototype.slice.call(arguments);\n                    //Take out first paramater (event object);\n                    params = params.splice(1);\n                    fn($scope, { $event: evt, $params: params });\n                    if (!$scope.$$phase) {\n                        $scope.$apply();\n                    }\n                });\n            });\n        }\n    };\n});\n/**\n * truncate - Truncates a string by a specified number of words\n *\n * @example\n * \t<p>\n * \t\t{{::post.body | truncate : 35}}\n * \t\t<a ng-if=\"::post.body.split(' ').length>35\">Read More</a>\n * \t</p>\n *\n * @param {string} value  The string to be truncated\n * @param {int} [wordLimit] The number of words to truncate at. If falsey, doesn't truncate.\n * @param {string} [ellipses] The string to use as an ellipses. Default: '…' (&hellip;)\n */\n'use strict';\n\nangular.module('ts.utils').filter('tsTruncate', function () {\n  return function (value, wordLimit) {\n    var ellipses = arguments.length <= 2 || arguments[2] === undefined ? '…' : arguments[2];\n\n    if (!value || !angular.isNumber(wordLimit)) return value;\n\n    var words = value.split(' ');\n\n    if (words.length > wordLimit) {\n      value = words.slice(0, wordLimit).join(' ');\n\n      if (ellipses) value += ellipses;\n    }\n\n    return value;\n  };\n});\n/**\n * ts-tooltip - Shows a tooltip with an arrow pointing to the element the directive is applied to.\n *\n * @note depends on jQuery\n *\n * @example\n *   <input ts-tooltip=\"Some message here will be compiled and linked against elements scope\" />\n *\n */\n\n'use strict';\n\nangular.module('ts.utils').directive('tsTooltip', function ($templateCache, $compile) {\n\n  return {\n    restrict: 'A',\n    scope: {\n      tsTooltip: '@',\n      tsTooltipDirection: '@',\n      tsTooltipEvent: '@',\n      tsTooltipShow: '='\n    },\n    link: function link($scope, $element, $attrs) {\n      var template = $templateCache.get('templates/tsTooltip.html');\n      var direction = $scope.tsTooltipDirection || 'right';\n      var eventType = $scope.tsTooltipEvent || 'mouseenter';\n      var isVisible = false;\n\n      var newTooltip = $compile(template)($scope);\n      newTooltip[0].style.visibility = 'hidden';\n\n      var tooltipMain = newTooltip.find(\"#tooltipMain\");\n      tooltipMain.addClass(direction);\n\n      $element.after(newTooltip);\n\n      function makeVisible() {\n        if (!isVisible) {\n\n          isVisible = true;\n\n          newTooltip[0].style.visibility = 'visible';\n\n          switch (direction) {\n            case 'right':\n              newTooltip[0].style.left = '10px';\n              newTooltip[0].style.top = -newTooltip.children()[0].offsetHeight / 2 + 'px';\n              break;\n            case 'left':\n              newTooltip[0].style.left = -$element[0].offsetWidth - newTooltip.children()[0].offsetWidth - 10 + 'px';\n              newTooltip[0].style.top = -newTooltip.children()[0].offsetHeight / 2 + 'px';\n              break;\n            case 'top':\n              newTooltip[0].style.left = -$element[0].offsetWidth / 2 - newTooltip.children()[0].offsetWidth / 2 + 'px';\n              newTooltip[0].style.top = -$element[0].offsetHeight / 2 - newTooltip.children()[0].offsetHeight - 10 + 'px';\n              break;\n            case 'bottom':\n              newTooltip[0].style.left = -$element[0].offsetWidth / 2 - newTooltip.children()[0].offsetWidth / 2 + 'px';\n              newTooltip[0].style.top = $element[0].offsetHeight / 2 + 'px';\n              break;\n          }\n        }\n      }\n\n      function makeInvisible() {\n        if (isVisible) {\n          isVisible = false;\n          newTooltip[0].style.visibility = 'hidden';\n        }\n      }\n\n      function toggleVisibility() {\n        if (isVisible) {\n          makeInvisible();\n        } else {\n          makeVisible();\n        }\n      }\n\n      if ($attrs.tsTooltipShow === undefined) {\n        switch (eventType) {\n          case 'mouseenter':\n            $element.on('mouseenter', makeVisible);\n            $element.on('mouseleave', makeInvisible);\n            break;\n          case 'click':\n            $element.on('click', toggleVisibility);\n            break;\n        }\n      } else {\n        $scope.$watch('tsTooltipShow', function (newVal, oldVal) {\n          if (newVal) {\n            makeVisible();\n          } else {\n            makeInvisible();\n          }\n        });\n      }\n    }\n  };\n});\n\n/**\n * scrollOn - $broadcast()/$emit() a $scope event with the location to trigger scrolling\n *\n * @example\n *   <ul scroll-on=\"someEventName\" style=\"overflow: auto\">...</ul>\n *   ...\n *   var location = 'bottom';\n *   $scope.$broadcast('someEventName', location)\n *\n * @param location {'top'|'bottom'|offset} must be passed as event data\n */\n'use strict';\n\nangular.module('ts.utils').directive('scrollOn', function ($timeout) {\n  return {\n    link: {\n      pre: function pre($scope, $element, $attrs) {\n        $scope.$on($attrs.scrollOn, function (event, location) {\n          // let updates render\n          $timeout(function () {\n            if (location === 'bottom') {\n              $element[0].scrollTop = $element[0].scrollHeight;\n            } else if (location === 'top') {\n              $element[0].scrollTop = 0;\n            } else {\n              $element[0].scrollTop = location;\n            }\n          }, true);\n        });\n      }\n    }\n  };\n});\n/**\n * focusOn - Focuses an input on scope event\n *\n * @note depends on jQuery\n *\n * @example\n *   <input focus-on=\"someEventName\">\n *   or\n *   <input focus-on=\"focus-row-{{$index}}\">\n *   or\n *   <p focus-on=\"anotherEvent\"></p>\n *   ...\n *   $scope.$broadcast('someEventName');\n *   $scope.$broadcast('focus-row-2');\n *   $scope.$broadcast('anotherEvent');\n *\n *   focusOnConfigProvider - can be injected into a .config(function(focusOnConfigProvider){}) block to configure the\n *   app wide settings for the focusOn directive\n *\n *   Settings include:\n *      offset - number of pixels to offset the scroll to for a header or other info that appears above the element you\n *      want to scroll to the top of the screen.  The offset is subtracted from the computed scroll position\n *\n *      autoCenter - boolean if true will use the element height and document body height to scroll the element to the\n *      center of the screen instead of the top\n *\n *   App wide settings can be overridden using attributes along with the focus-on directive.  The attributes for the\n *   offset and autoCenter are focus-on-offset and focus-on-auto-center respectively.\n *\n */\n'use strict';\n\nangular.module('ts.utils').directive('focusOn', function ($window, focusOnConfig) {\n  return {\n    link: function link($scope, $element, $attrs) {\n      var listener = angular.noop;\n      $attrs.$observe('focusOn', function (newVal) {\n        // Stop listening to old event name\n        listener();\n        // Listen to new event name\n        listener = $scope.$on(newVal, function (speed) {\n          speed = speed || 1000;\n          // Center element on screen\n          if ($element.parents('.reveal-modal').length) {\n            var targetWindow = $element.parents('.reveal-modal .content');\n            targetWindow.animate({\n              scrollTop: $element.offset().top - targetWindow.offset().top + targetWindow.scrollTop()\n            }, {\n              speed: speed,\n              complete: function complete() {\n                // Focus element (if input)\n                $element[0].focus();\n              }\n            });\n          } else {\n            var offset = $element.offset().top;\n\n            // Use provider configured offset\n            var extraOffset = focusOnConfig.offset;\n\n            // If attribute is set override provider configured offset\n            if ($attrs.focusOnOffset !== undefined) {\n              extraOffset = parseInt($attrs.focusOnOffset);\n            }\n\n            // Check if provider or attribute set autoCenter/auto-center to true if so use offset/2 ignores the extra\n            // offset in this case\n            if (focusOnConfig.autoCenter && $attrs.focusOnAutoCenter === undefined || $attrs.focusOnAutoCenter && $attrs.focusOnAutoCenter == 'true') {\n              offset = offset - window.innerHeight / 2 - $element[0].clientHeight / 2;\n            } else {\n              offset = offset - extraOffset;\n            }\n\n            $('body').animate({ scrollTop: offset }, {\n              speed: speed,\n              complete: function complete() {\n                // Focus element (if input)\n                $element[0].focus();\n              }\n            });\n          }\n        });\n      });\n    }\n  };\n}).provider('focusOnConfig', function () {\n  var _offset = 0;\n  var _autoCenter = false;\n\n  this.autoCenter = function (value) {\n    _autoCenter = value;\n  };\n\n  this.offset = function (value) {\n    _offset = value;\n  };\n\n  this.$get = function () {\n    return {\n      offset: _offset,\n      autoCenter: _autoCenter\n    };\n  };\n});\n/**\n * autoGrow - Increases height of textarea while typing\n *\n * @note use with min-height, max-height and box-sizing:border-box\n *\n * @example\n * \t<textarea auto-grow></textarea>\n */\n'use strict';\n\nangular.module('ts.utils').directive('autoGrow', function ($timeout) {\n  return {\n    restrict: 'A',\n    link: function link($scope, $element, $attrs) {\n      function grow() {\n        $element[0].style.height = 0; // autoshrink - need accurate scrollHeight\n        $element[0].style.height = $element[0].scrollHeight + 'px';\n      }\n      $element.on('input', grow);\n      $timeout(grow, true);\n    }\n  };\n});","angular.module('ts.utils', []);\n","/**\n * @TODO remove in liue of ui-utils\n * General-purpose Event binding. Bind any event not natively supported by Angular\n * Pass an object with keynames for events to ui-event\n * Allows $event object and $params object to be passed\n *\n * @example <input ui-event=\"{ focus : 'counter++', blur : 'someCallback()' }\">\n * @example <input ui-event=\"{ myCustomEvent : 'myEventHandler($event, $params)'}\">\n *\n * @param ui-event {string|object literal} The event to bind to as a string or a hash of events with their callbacks\n */\nangular.module('ts.utils').directive('uiEvent', function ($parse) {\n    return {\n        priority: 100,\n        link: function ($scope, $elm, $attrs) {\n            var events = $scope.$eval($attrs.uiEvent);\n            angular.forEach(events, function (uiEvent, eventName) {\n                var fn = $parse(uiEvent);\n                $elm.bind(eventName, function (evt) {\n                    var params = Array.prototype.slice.call(arguments);\n                    //Take out first paramater (event object);\n                    params = params.splice(1);\n                    fn($scope, {$event: evt, $params: params});\n                    if (!$scope.$$phase) {\n                        $scope.$apply();\n                    }\n                });\n            });\n        }\n    };\n});\n","/**\n * truncate - Truncates a string by a specified number of words\n *\n * @example\n * \t<p>\n * \t\t{{::post.body | truncate : 35}}\n * \t\t<a ng-if=\"::post.body.split(' ').length>35\">Read More</a>\n * \t</p>\n *\n * @param {string} value  The string to be truncated\n * @param {int} [wordLimit] The number of words to truncate at. If falsey, doesn't truncate.\n * @param {string} [ellipses] The string to use as an ellipses. Default: '…' (&hellip;)\n */\n angular.module('ts.utils').filter('tsTruncate', function() {\n  return function(value, wordLimit, ellipses = '…'){\n    if (!value || !angular.isNumber(wordLimit))\n      return value;\n\n    var words = value.split(' ');\n\n    if (words.length > wordLimit) {\n      value = words.slice(0, wordLimit).join(' ');\n\n      if (ellipses)\n        value += ellipses;\n    }\n\n    return value;\n  }\n});\n","/**\n * ts-tooltip - Shows a tooltip with an arrow pointing to the element the directive is applied to.\n *\n * @note depends on jQuery\n *\n * @example\n *   <input ts-tooltip=\"Some message here will be compiled and linked against elements scope\" />\n *\n */\n\n\nangular.module('ts.utils')\n\n  .directive('tsTooltip', function($templateCache, $compile){\n\n    return {\n      restrict:'A',\n      scope:{\n        tsTooltip:'@',\n        tsTooltipDirection:'@',\n        tsTooltipEvent:'@',\n        tsTooltipShow:'='\n      },\n      link: function($scope, $element, $attrs) {\n        var template = $templateCache.get('templates/tsTooltip.html');\n        var direction = $scope.tsTooltipDirection || 'right';\n        var eventType = $scope.tsTooltipEvent || 'mouseenter';\n        var isVisible = false;\n\n        var newTooltip = $compile(template)($scope);\n        newTooltip[0].style.visibility = 'hidden';\n\n        var tooltipMain = newTooltip.find(\"#tooltipMain\");\n        tooltipMain.addClass(direction);\n\n        $element.after(newTooltip);\n\n        function makeVisible(){\n          if(!isVisible){\n\n            isVisible = true;\n\n\n            newTooltip[0].style.visibility='visible';\n\n            switch(direction) {\n              case 'right':\n                newTooltip[0].style.left='10px';\n                newTooltip[0].style.top=-newTooltip.children()[0].offsetHeight/2+'px';\n                break;\n              case 'left':\n                newTooltip[0].style.left=-$element[0].offsetWidth-newTooltip.children()[0].offsetWidth-10+'px';\n                newTooltip[0].style.top=-newTooltip.children()[0].offsetHeight/2+'px';\n                break;\n              case 'top':\n                newTooltip[0].style.left=-$element[0].offsetWidth/2-newTooltip.children()[0].offsetWidth/2+'px';\n                newTooltip[0].style.top=-$element[0].offsetHeight/2-newTooltip.children()[0].offsetHeight-10+'px';\n                break;\n              case 'bottom':\n                newTooltip[0].style.left=-$element[0].offsetWidth/2-newTooltip.children()[0].offsetWidth/2+'px';\n                newTooltip[0].style.top=$element[0].offsetHeight/2 + 'px';\n                break;\n            }\n\n          }\n        }\n\n        function makeInvisible(){\n          if(isVisible){\n            isVisible = false;\n            newTooltip[0].style.visibility = 'hidden';\n          }\n        }\n\n        function toggleVisibility(){\n          if(isVisible){\n            makeInvisible();\n          }\n          else{\n            makeVisible();\n          }\n        }\n\n        if($attrs.tsTooltipShow === undefined){\n          switch(eventType){\n            case 'mouseenter':\n              $element.on('mouseenter', makeVisible);\n              $element.on('mouseleave', makeInvisible);\n              break;\n            case 'click':\n              $element.on('click', toggleVisibility);\n              break;\n          }\n        }\n        else{\n          $scope.$watch('tsTooltipShow',function(newVal, oldVal){\n            if(newVal){\n              makeVisible();\n            }\n            else{\n              makeInvisible();\n            }\n          })\n        }\n\n\n\n\n      }\n    };\n  });\n","\n/**\n * scrollOn - $broadcast()/$emit() a $scope event with the location to trigger scrolling\n *\n * @example\n *   <ul scroll-on=\"someEventName\" style=\"overflow: auto\">...</ul>\n *   ...\n *   var location = 'bottom';\n *   $scope.$broadcast('someEventName', location)\n *\n * @param location {'top'|'bottom'|offset} must be passed as event data\n */\nangular.module('ts.utils').directive('scrollOn', function($timeout) {\n  return {\n    link: {\n      pre: function($scope, $element, $attrs) {\n        $scope.$on($attrs.scrollOn, function(event, location){\n          // let updates render\n          $timeout(function(){\n            if (location === 'bottom') {\n              $element[0].scrollTop = $element[0].scrollHeight;\n            }\n            else if (location === 'top') {\n              $element[0].scrollTop = 0;\n            }\n            else {\n              $element[0].scrollTop = location;\n            }\n          }, true);\n        });\n      }\n    }\n  };\n});\n","/**\n * focusOn - Focuses an input on scope event\n *\n * @note depends on jQuery\n *\n * @example\n *   <input focus-on=\"someEventName\">\n *   or\n *   <input focus-on=\"focus-row-{{$index}}\">\n *   or\n *   <p focus-on=\"anotherEvent\"></p>\n *   ...\n *   $scope.$broadcast('someEventName');\n *   $scope.$broadcast('focus-row-2');\n *   $scope.$broadcast('anotherEvent');\n *\n *   focusOnConfigProvider - can be injected into a .config(function(focusOnConfigProvider){}) block to configure the\n *   app wide settings for the focusOn directive\n *\n *   Settings include:\n *      offset - number of pixels to offset the scroll to for a header or other info that appears above the element you\n *      want to scroll to the top of the screen.  The offset is subtracted from the computed scroll position\n *\n *      autoCenter - boolean if true will use the element height and document body height to scroll the element to the\n *      center of the screen instead of the top\n *\n *   App wide settings can be overridden using attributes along with the focus-on directive.  The attributes for the\n *   offset and autoCenter are focus-on-offset and focus-on-auto-center respectively.\n *\n */\n angular.module('ts.utils').directive('focusOn', function($window, focusOnConfig){\n  return {\n    link: function($scope, $element, $attrs) {\n      var listener = angular.noop;\n      $attrs.$observe('focusOn', function(newVal){\n        // Stop listening to old event name\n        listener();\n        // Listen to new event name\n        listener = $scope.$on(newVal, function(speed){\n          speed = speed || 1000;\n          // Center element on screen\n          if($element.parents('.reveal-modal').length) {\n            var targetWindow = $element.parents('.reveal-modal .content');\n            targetWindow.animate({\n              scrollTop: $element.offset().top - targetWindow.offset().top + targetWindow.scrollTop()\n            }, {\n              speed: speed,\n              complete: function complete() {\n                // Focus element (if input)\n                $element[0].focus();\n              }\n            });\n          }\n          else {\n            var offset = $element.offset().top;\n\n            // Use provider configured offset\n            var extraOffset = focusOnConfig.offset;\n\n            // If attribute is set override provider configured offset\n            if($attrs.focusOnOffset !== undefined){\n              extraOffset = parseInt($attrs.focusOnOffset);\n            }\n\n            // Check if provider or attribute set autoCenter/auto-center to true if so use offset/2 ignores the extra\n            // offset in this case\n            if( (focusOnConfig.autoCenter && $attrs.focusOnAutoCenter===undefined ) ||\n                ($attrs.focusOnAutoCenter && $attrs.focusOnAutoCenter=='true') ) {\n              offset = offset - window.innerHeight/2 - $element[0].clientHeight/2;\n            }\n            else{\n              offset = offset - extraOffset;\n            }\n\n            $('body').animate({ scrollTop: offset }, {\n              speed: speed,\n              complete: function complete() {\n                // Focus element (if input)\n                $element[0].focus();\n              }\n            });\n          }\n        });\n      });\n    }\n  };\n})\n\n.provider('focusOnConfig', function(){\n  var _offset = 0;\n  var _autoCenter = false;\n\n  this.autoCenter = function(value){\n    _autoCenter = value;\n  };\n\n  this.offset = function(value){\n    _offset = value;\n  };\n\n  this.$get = function(){\n    return {\n      offset: _offset,\n      autoCenter:_autoCenter\n    };\n  };\n\n});\n","/**\n * autoGrow - Increases height of textarea while typing\n *\n * @note use with min-height, max-height and box-sizing:border-box\n *\n * @example\n * \t<textarea auto-grow></textarea>\n */\n angular.module('ts.utils').directive('autoGrow', function($timeout) {\n  return {\n    restrict: 'A',\n    link: function($scope, $element, $attrs) {\n      function grow() {\n        $element[0].style.height = 0; // autoshrink - need accurate scrollHeight\n        $element[0].style.height = $element[0].scrollHeight + 'px';\n      }\n      $element.on('input', grow);\n      $timeout(grow, true);\n    }\n  }\n});\n"],"sourceRoot":"/source/"}